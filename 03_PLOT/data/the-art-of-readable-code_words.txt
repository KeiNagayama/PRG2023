the
art
of
readable
code
dustin
boswell
and
trevor
foucher
beijing
cambridge
farnham
k√∂ln
sebastopol
tokyo
the
art
of
readable
code
by
dustin
boswell
and
trevor
foucher
copyright
dustin
boswell
and
trevor
foucher
all
rights
reserved
printed
in
the
united
states
of
america
published
by
o
reilly
media
inc
gravenstein
highway
north
sebastopol
ca
o
reilly
books
may
be
purchased
for
educational
business
or
sales
promotional
use
online
editions
are
also
available
for
most
titles
http
my
safaribooksonline
com
for
more
information
contact
our
corporate
institutional
sales
department
or
corporate
oreilly
com
editor
mary
treseler
production
editor
teresa
elsey
copyeditor
nancy
wolfe
kotary
proofreader
teresa
elsey
november
indexer
potomac
indexing
llc
cover
designer
susan
thompson
interior
designer
david
futato
illustrators
dave
allred
and
robert
romano
first
edition
revision
history
for
the
first
edition
first
release
see
http
oreilly
com
catalog
errata
csp
isbn
for
release
details
nutshell
handbook
the
nutshell
handbook
logo
and
the
o
reilly
logo
are
registered
trademarks
of
o
reilly
media
inc
the
art
of
readable
code
the
image
of
sheet
music
and
related
trade
dress
are
trademarks
of
o
reilly
media
inc
many
of
the
designations
used
by
manufacturers
and
sellers
to
distinguish
their
products
are
claimed
as
trademarks
where
those
designations
appear
in
this
book
and
o
reilly
media
inc
was
aware
of
a
trademark
claim
the
designations
have
been
printed
in
caps
or
initial
caps
while
every
precaution
has
been
taken
in
the
preparation
of
this
book
the
publisher
and
authors
assume
no
responsibility
for
errors
or
omissions
or
for
damages
resulting
from
the
use
of
the
information
contained
herein
isbn
lsi
contents
preface
code
should
be
easy
to
understand
what
makes
code
better
the
fundamental
theorem
of
readability
is
smaller
always
better
does
time
till
understanding
conflict
with
other
goals
the
hard
part
part
one
vii
surface
level
improvements
packing
information
into
names
choose
specific
words
avoid
generic
names
like
tmp
and
retval
prefer
concrete
names
over
abstract
names
attaching
extra
information
to
a
name
how
long
should
a
name
be
use
name
formatting
to
convey
meaning
summary
names
that
can
t
be
misconstrued
example
filter
example
clip
text
length
prefer
min
and
max
for
inclusive
limits
prefer
first
and
last
for
inclusive
ranges
prefer
begin
and
end
for
inclusive
exclusive
ranges
naming
booleans
matching
expectations
of
users
example
evaluating
multiple
name
candidates
summary
aesthetics
why
do
aesthetics
matter
rearrange
line
breaks
to
be
consistent
and
compact
use
methods
to
clean
up
irregularity
use
column
alignment
when
helpful
pick
a
meaningful
order
and
use
it
consistently
organize
declarations
into
blocks
break
code
into
paragraphs
personal
style
versus
consistency
summary
iii
knowing
what
to
comment
what
not
to
comment
recording
your
thoughts
put
yourself
in
the
reader
s
shoes
final
thoughts
getting
over
writer
s
block
summary
making
comments
precise
and
compact
keep
comments
compact
avoid
ambiguous
pronouns
polish
sloppy
sentences
describe
function
behavior
precisely
use
input
output
examples
that
illustrate
corner
cases
state
the
intent
of
your
code
named
function
parameter
comments
use
information
dense
words
summary
part
two
simplifying
loops
and
logic
making
control
flow
easy
to
read
the
order
of
arguments
in
conditionals
the
order
of
if
else
blocks
the
conditional
expression
a
k
a
ternary
operator
avoid
do
while
loops
returning
early
from
a
function
the
infamous
goto
minimize
nesting
can
you
follow
the
flow
of
execution
summary
breaking
down
giant
expressions
explaining
variables
summary
variables
using
de
morgan
s
laws
abusing
short
circuit
logic
example
wrestling
with
complicated
logic
breaking
down
giant
statements
another
creative
way
to
simplify
expressions
summary
variables
and
readability
eliminating
variables
shrink
the
scope
of
your
variables
prefer
write
once
variables
a
final
example
summary
iv
contents
part
three
reorganizing
your
code
extracting
unrelated
subproblems
introductory
example
findclosestlocation
pure
utility
code
other
general
purpose
code
create
a
lot
of
general
purpose
code
project
specific
functionality
simplifying
an
existing
interface
reshaping
an
interface
to
your
needs
taking
things
too
far
summary
one
task
at
a
time
tasks
can
be
small
extracting
values
from
an
object
a
larger
example
summary
turning
thoughts
into
code
describing
logic
clearly
knowing
your
libraries
helps
applying
this
method
to
larger
problems
summary
writing
less
code
don
t
bother
implementing
that
feature
you
won
t
need
it
question
and
break
down
your
requirements
keeping
your
codebase
small
be
familiar
with
the
libraries
around
you
example
using
unix
tools
instead
of
coding
summary
part
four
selected
topics
testing
and
readability
make
tests
easy
to
read
and
maintain
what
s
wrong
with
this
test
making
this
test
more
readable
making
error
messages
readable
choosing
good
test
inputs
naming
test
functions
what
was
wrong
with
that
test
test
friendly
development
going
too
far
summary
designing
and
implementing
a
minute
hour
counter
the
problem
defining
the
class
interface
contents
v
a
vi
attempt
a
naive
solution
attempt
conveyor
belt
design
attempt
a
time
bucketed
design
comparing
the
three
solutions
summary
further
reading
index
contents
preface
vii
we
ve
worked
at
highly
successful
software
companies
with
outstanding
engineers
and
the
code
we
encounter
still
has
plenty
of
room
for
improvement
in
fact
we
ve
seen
some
really
ugly
code
and
you
probably
have
too
but
when
we
see
beautifully
written
code
it
s
inspiring
good
code
can
teach
you
what
s
going
on
very
quickly
it
s
fun
to
use
and
it
motivates
you
to
make
your
own
code
better
the
goal
of
this
book
is
help
you
make
your
code
better
and
when
we
say
code
we
literally
mean
the
lines
of
code
you
are
staring
at
in
your
editor
we
re
not
talking
about
the
overall
architecture
of
your
project
or
your
choice
of
design
patterns
those
are
certainly
important
but
in
our
experience
most
of
our
day
to
day
lives
as
programmers
are
spent
on
the
basic
stuff
like
naming
variables
writing
loops
and
attacking
problems
down
at
the
function
level
and
a
big
part
of
this
is
reading
and
editing
the
code
that
s
already
there
we
hope
you
ll
find
this
book
so
helpful
to
your
day
to
day
programming
that
you
ll
recommend
it
to
everyone
on
your
team
what
this
book
is
about
this
book
is
about
how
to
write
code
that
s
highly
readable
the
key
idea
in
this
book
is
that
code
should
be
easy
to
understand
specifically
your
goal
should
be
to
minimize
the
time
it
takes
someone
else
to
understand
your
code
this
book
explains
this
idea
and
illustrates
it
with
lots
of
examples
from
different
languages
including
c
python
javascript
and
java
we
ve
avoided
any
advanced
language
features
so
even
if
you
don
t
know
all
these
languages
it
should
still
be
easy
to
follow
along
in
our
experience
the
concepts
of
readability
are
mostly
language
independent
anyhow
each
chapter
dives
into
a
different
aspect
of
coding
and
how
to
make
it
easy
to
understand
the
book
is
divided
into
four
parts
surface
level
improvements
naming
commenting
and
aesthetics
simple
tips
that
apply
to
every
line
of
your
codebase
simplifying
loops
and
logic
ways
to
refine
the
loops
logic
and
variables
in
your
program
to
make
them
easier
to
understand
reorganizing
your
code
higher
level
ways
to
organize
large
blocks
of
code
and
attack
problems
at
the
function
level
selected
topics
applying
easy
to
understand
to
testing
and
to
a
larger
data
structure
coding
example
viii
preface
how
to
read
this
book
our
book
is
intended
to
be
a
fun
casual
read
we
hope
most
readers
will
read
the
whole
book
in
a
week
or
two
the
chapters
are
ordered
by
difficulty
basic
topics
are
at
the
beginning
and
more
advanced
topics
are
at
the
end
however
each
chapter
is
self
contained
and
can
be
read
in
isolation
so
feel
free
to
skip
around
if
you
d
like
using
code
examples
this
book
is
here
to
help
you
get
your
job
done
in
general
you
may
use
the
code
in
this
book
in
your
programs
and
documentation
you
do
not
need
to
contact
us
for
permission
unless
you
re
reproducing
a
significant
portion
of
the
code
for
example
writing
a
program
that
uses
several
chunks
of
code
from
this
book
does
not
require
permission
selling
or
distributing
a
cd
rom
of
examples
from
o
reilly
books
does
require
permission
answering
a
question
by
citing
this
book
and
quoting
example
code
does
not
require
permission
incorporating
a
significant
amount
of
example
code
from
this
book
into
your
product
s
documentation
does
require
permission
we
appreciate
but
do
not
require
attribution
an
attribution
usually
includes
the
title
author
publisher
and
isbn
for
example
the
art
of
readable
code
by
dustin
boswell
and
trevor
foucher
copyright
dustin
boswell
and
trevor
foucher
if
you
feel
your
use
of
code
examples
falls
outside
fair
use
or
the
permission
given
above
feel
free
to
contact
us
at
permissions
oreilly
com
safari
books
online
safari
books
online
is
an
on
demand
digital
library
that
lets
you
easily
search
over
technology
and
creative
reference
books
and
videos
to
find
the
answers
you
need
quickly
with
a
subscription
you
can
read
any
page
and
watch
any
video
from
our
library
online
read
books
on
your
cell
phone
and
mobile
devices
access
new
titles
before
they
are
available
for
print
and
get
exclusive
access
to
manuscripts
in
development
and
post
feedback
for
the
authors
copy
and
paste
code
samples
organize
your
favorites
download
chapters
bookmark
key
sections
create
notes
print
out
pages
and
benefit
from
tons
of
other
time
saving
features
o
reilly
media
has
uploaded
this
book
to
the
safari
books
online
service
to
have
full
digital
access
to
this
book
and
others
on
similar
topics
from
o
reilly
and
other
publishers
sign
up
for
free
at
http
my
safaribooksonline
com
preface
ix
how
to
contact
us
please
address
comments
and
questions
concerning
this
book
to
the
publisher
o
reilly
media
inc
gravenstein
highway
north
sebastopol
ca
in
the
united
states
or
canada
international
or
local
fax
we
have
a
web
page
for
this
book
where
we
list
errata
examples
and
any
additional
information
you
can
access
this
page
at
http
shop
oreilly
com
product
do
to
comment
or
ask
technical
questions
about
this
book
send
email
to
bookquestions
oreilly
com
for
more
information
about
our
books
courses
conferences
and
news
see
our
website
at
http
www
oreilly
com
find
us
on
facebook
http
facebook
com
oreilly
follow
us
on
twitter
http
twitter
com
oreillymedia
watch
us
on
youtube
http
www
youtube
com
oreillymedia
acknowledgments
we
d
like
to
thank
our
colleagues
who
donated
their
time
to
review
our
entire
manuscript
including
alan
davidson
josh
ehrlich
rob
konigsberg
archie
russell
gabe
w
and
asaph
zemach
any
errors
in
the
book
are
entirely
their
fault
just
kidding
we
re
grateful
to
the
many
reviewers
who
gave
us
detailed
feedback
on
various
drafts
of
our
book
including
michael
hunger
george
heineman
and
chuck
hudson
we
also
got
numerous
ideas
and
feedback
from
john
blackburn
tim
dasilva
dennis
geels
steve
gerding
chris
harris
josh
hyman
joel
ingram
erik
mavrinac
greg
miller
anatole
paine
and
nick
white
thanks
to
the
numerous
online
commenters
who
reviewed
our
draft
on
o
reilly
s
ofps
system
thanks
to
the
team
at
o
reilly
for
their
endless
patience
and
support
specifically
mary
treseler
editor
teresa
elsey
production
editor
nancy
kotary
copyeditor
rob
romano
illustrator
jessica
hosman
tools
and
abby
fox
tools
and
also
to
our
cartoonist
dave
allred
who
made
our
crazy
cartoon
ideas
come
to
life
lastly
we
d
like
to
thank
melissa
and
suzanne
for
encouraging
us
along
the
way
and
putting
up
with
incessant
programming
conversations
x
preface
chapter
one
code
should
be
easy
to
understand
over
the
past
five
years
we
have
collected
hundreds
of
examples
of
bad
code
much
of
it
our
own
and
analyzed
what
made
it
bad
and
what
principles
techniques
were
used
to
make
it
better
what
we
noticed
is
that
all
of
the
principles
stem
from
a
single
theme
key
idea
code
should
be
easy
to
understand
we
believe
this
is
the
most
important
guiding
principle
you
can
use
when
deciding
how
to
write
your
code
throughout
the
book
we
ll
show
how
to
apply
this
principle
to
different
aspects
of
your
day
to
day
coding
but
before
we
begin
we
ll
elaborate
on
this
principle
and
justify
why
it
s
so
important
what
makes
code
better
most
programmers
including
the
authors
make
programming
decisions
based
on
gut
feel
and
intuition
we
all
know
that
code
like
this
for
node
node
list
head
node
null
node
node
next
print
node
data
is
better
than
code
like
this
node
node
list
head
if
node
null
return
while
node
next
null
print
node
data
node
node
next
if
node
null
print
node
data
even
though
both
examples
behave
exactly
the
same
but
a
lot
of
times
it
s
a
tougher
choice
for
example
is
this
code
return
exponent
mantissa
exponent
mantissa
exponent
better
or
worse
than
if
exponent
return
mantissa
exponent
else
return
mantissa
exponent
the
first
version
is
more
compact
but
the
second
version
is
less
intimidating
which
criterion
is
more
important
in
general
how
do
you
decide
which
way
to
code
something
chapter
one
the
fundamental
theorem
of
readability
after
studying
many
code
examples
like
this
we
came
to
the
conclusion
that
there
is
one
metric
for
readability
that
is
more
important
than
any
other
it
s
so
important
that
we
call
it
the
fundamental
theorem
of
readability
key
idea
code
should
be
written
to
minimize
the
time
it
would
take
for
someone
else
to
understand
it
what
do
we
mean
by
this
quite
literally
if
you
were
to
take
a
typical
colleague
of
yours
and
measure
how
much
time
it
took
him
to
read
through
your
code
and
understand
it
this
timetill
understanding
is
the
theoretical
metric
you
want
to
minimize
and
when
we
say
understand
we
have
a
very
high
bar
for
this
word
for
someone
to
fully
understand
your
code
they
should
be
able
to
make
changes
to
it
spot
bugs
and
understand
how
it
interacts
with
the
rest
of
your
code
now
you
might
be
thinking
who
cares
if
someone
else
can
understand
it
i
m
the
only
one
using
the
code
even
if
you
re
on
a
one
man
project
it
s
worth
pursuing
this
goal
that
someone
else
might
be
you
six
months
later
when
your
own
code
looks
unfamiliar
to
you
and
you
never
know
someone
might
join
your
project
or
your
throwaway
code
might
get
reused
for
another
project
is
smaller
always
better
generally
speaking
the
less
code
you
write
to
solve
a
problem
the
better
see
chapter
writing
less
code
it
probably
takes
less
time
to
understand
a
line
class
than
a
line
class
but
fewer
lines
isn
t
always
better
there
are
plenty
of
times
when
a
one
line
expression
like
assert
bucket
findbucket
key
bucket
isoccupied
takes
more
time
to
understand
than
if
it
were
two
lines
bucket
findbucket
key
if
bucket
null
assert
bucket
isoccupied
similarly
a
comment
can
make
you
understand
the
code
more
quickly
even
though
it
adds
code
to
the
file
fast
version
of
hash
hash
c
hash
hash
hash
hash
c
so
even
though
having
fewer
lines
of
code
is
a
good
goal
minimizing
the
time
tillunderstanding
is
an
even
better
goal
code
should
be
easy
to
understand
does
time
till
understanding
conflict
with
other
goals
you
might
be
thinking
what
about
other
constraints
like
making
code
efficient
or
well
architected
or
easy
to
test
and
so
on
don
t
these
sometimes
conflict
with
wanting
to
make
code
easy
to
understand
we
ve
found
that
these
other
goals
don
t
interfere
much
at
all
even
in
the
realm
of
highly
optimized
code
there
are
still
ways
to
make
it
highly
readable
as
well
and
making
your
code
easy
to
understand
often
leads
to
code
that
is
well
architected
and
easy
to
test
the
rest
of
the
book
discusses
how
to
apply
easy
to
read
in
different
circumstances
but
remember
when
in
doubt
the
fundamental
theorem
of
readability
trumps
any
other
rule
or
principle
in
this
book
also
some
programmers
have
a
compulsive
need
to
fix
any
code
that
isn
t
perfectly
factored
it
s
always
important
to
step
back
and
ask
is
this
code
easy
to
understand
if
so
it
s
probably
fine
to
move
on
to
other
code
the
hard
part
yes
it
requires
extra
work
to
constantly
think
about
whether
an
imaginary
outsider
would
find
your
code
easy
to
understand
doing
so
requires
turning
on
a
part
of
your
brain
that
might
not
have
been
on
while
coding
before
but
if
you
adopt
this
goal
as
we
have
we
re
certain
you
will
become
a
better
coder
have
fewer
bugs
take
more
pride
in
your
work
and
produce
code
that
everyone
around
you
will
love
to
use
so
let
s
get
started
chapter
one
part
i
surface
level
improvements
we
begin
our
tour
of
readability
with
what
we
consider
surface
level
improvements
picking
good
names
writing
good
comments
and
formatting
your
code
neatly
these
types
of
changes
are
easy
to
apply
you
can
make
them
in
place
without
having
to
refactor
your
code
or
change
how
the
program
runs
you
can
also
make
them
incrementally
without
a
huge
time
investment
these
topics
are
very
important
because
they
affect
every
line
of
code
in
your
codebase
although
each
change
may
seem
small
in
aggregate
they
can
make
a
huge
improvement
to
a
codebase
if
your
code
has
great
names
well
written
comments
and
clean
use
of
whitespace
your
code
will
be
much
easier
to
read
of
course
there
s
a
lot
more
beneath
the
surface
level
when
it
comes
to
readability
and
we
ll
cover
that
in
later
parts
of
the
book
but
the
material
in
this
part
is
so
widely
applicable
for
so
little
effort
that
it
s
worth
covering
first
chapter
two
packing
information
into
names
whether
you
re
naming
a
variable
a
function
or
a
class
a
lot
of
the
same
principles
apply
we
like
to
think
of
a
name
as
a
tiny
comment
even
though
there
isn
t
much
room
you
can
convey
a
lot
of
information
by
choosing
a
good
name
key
idea
pack
information
into
your
names
a
lot
of
the
names
we
see
in
programs
are
vague
like
tmp
even
words
that
may
seem
reasonable
such
as
size
or
get
don
t
pack
much
information
this
chapter
shows
you
how
to
pick
names
that
do
this
chapter
is
organized
into
six
specific
topics
choosing
specific
words
avoiding
generic
names
or
knowing
when
to
use
them
using
concrete
names
instead
of
abstract
names
attaching
extra
information
to
a
name
by
using
a
suffix
or
prefix
deciding
how
long
a
name
should
be
using
name
formatting
to
pack
extra
information
choose
specific
words
part
of
packing
information
into
names
is
choosing
words
that
are
very
specific
and
avoiding
empty
words
for
example
the
word
get
is
very
unspecific
as
in
this
example
def
getpage
url
the
word
get
doesn
t
really
say
much
does
this
method
get
a
page
from
a
local
cache
from
a
database
or
from
the
internet
if
it
s
from
the
internet
a
more
specific
name
might
be
fetchpage
or
downloadpage
here
s
an
example
of
a
binarytree
class
class
binarytree
int
size
what
would
you
expect
the
size
method
to
return
the
height
of
the
tree
the
number
of
nodes
or
the
memory
footprint
of
the
tree
the
problem
is
that
size
doesn
t
convey
much
information
a
more
specific
name
would
be
height
numnodes
or
memorybytes
chapter
two
as
another
example
suppose
you
have
some
sort
of
thread
class
class
thread
void
stop
the
name
stop
is
okay
but
depending
on
what
exactly
it
does
there
might
be
a
more
specific
name
for
instance
you
might
call
it
kill
instead
if
it
s
a
heavyweight
operation
that
can
t
be
undone
or
you
might
call
it
pause
if
there
is
a
way
to
resume
it
finding
more
colorful
words
don
t
be
afraid
to
use
a
thesaurus
or
ask
a
friend
for
better
name
suggestions
english
is
a
rich
language
and
there
are
a
lot
of
words
to
choose
from
here
are
some
examples
of
a
word
as
well
as
more
colorful
versions
that
might
apply
to
your
situation
word
alternatives
send
deliver
dispatch
announce
distribute
route
find
search
extract
locate
recover
start
launch
create
begin
open
make
create
set
up
build
generate
compose
add
new
don
t
get
carried
away
though
in
php
there
is
a
function
to
explode
a
string
that
s
a
colorful
name
and
it
paints
a
good
picture
of
breaking
something
into
pieces
but
how
is
it
any
different
packing
information
into
names
from
split
the
two
functions
are
different
but
it
s
hard
to
guess
their
differences
based
on
the
name
key
idea
it
s
better
to
be
clear
and
precise
than
to
be
cute
avoid
generic
names
like
tmp
and
retval
names
like
tmp
retval
and
foo
are
usually
cop
outs
that
mean
i
can
t
think
of
a
name
instead
of
using
an
empty
name
like
this
pick
a
name
that
describes
the
entity
s
value
or
purpose
for
example
here
s
a
javascript
function
that
uses
retval
var
euclidean
norm
function
v
var
retval
for
var
i
i
v
length
i
retval
v
i
v
i
return
math
sqrt
retval
it
s
tempting
to
use
retval
when
you
can
t
think
of
a
better
name
for
your
return
value
but
retval
doesn
t
contain
much
information
other
than
i
am
a
return
value
which
is
usually
obvious
anyway
a
better
name
would
describe
the
purpose
of
the
variable
or
the
value
it
contains
in
this
case
the
variable
is
accumulating
the
sum
of
the
squares
of
v
so
a
better
name
is
sum
squares
this
would
announce
the
purpose
of
the
variable
upfront
and
might
help
catch
a
bug
for
instance
imagine
if
the
inside
of
the
loop
were
accidentally
retval
v
i
this
bug
would
be
more
obvious
if
the
name
were
sum
squares
sum
squares
v
i
where
s
the
square
that
we
re
summing
bug
advice
the
name
retval
doesn
t
pack
much
information
instead
use
a
name
that
describes
the
variable
s
value
there
are
however
some
cases
where
generic
names
do
carry
meaning
let
s
take
a
look
at
when
it
makes
sense
to
use
them
chapter
two
tmp
consider
the
classic
case
of
swapping
two
variables
if
right
left
tmp
right
right
left
left
tmp
in
cases
like
these
the
name
tmp
is
perfectly
fine
the
variable
s
sole
purpose
is
temporary
storage
with
a
lifetime
of
only
a
few
lines
the
name
tmp
conveys
specific
meaning
to
the
reader
that
this
variable
has
no
other
duties
it
s
not
being
passed
around
to
other
functions
or
being
reset
or
reused
multiple
times
but
here
s
a
case
where
tmp
is
just
used
out
of
laziness
string
tmp
user
name
tmp
user
phone
number
tmp
user
email
template
set
user
info
tmp
even
though
this
variable
has
a
short
lifespan
being
temporary
storage
isn
t
the
most
important
thing
about
this
variable
instead
a
name
like
user
info
would
be
more
descriptive
in
the
following
case
tmp
should
be
in
the
name
but
just
as
a
part
of
it
tmp
file
tempfile
namedtemporaryfile
savedata
tmp
file
notice
that
we
named
the
variable
tmp
file
and
not
just
tmp
because
it
is
a
file
object
imagine
if
we
just
called
it
tmp
savedata
tmp
looking
at
just
this
one
line
of
code
it
isn
t
clear
if
tmp
is
a
file
a
filename
or
maybe
even
the
data
being
written
advice
the
name
tmp
should
be
used
only
in
cases
when
being
short
lived
and
temporary
is
the
most
important
fact
about
that
variable
packing
information
into
names
loop
iterators
names
like
i
j
iter
and
it
are
commonly
used
as
indices
and
loop
iterators
even
though
these
names
are
generic
they
re
understood
to
mean
i
am
an
iterator
in
fact
if
you
used
one
of
these
names
for
some
other
purpose
it
would
be
confusing
so
don
t
do
that
but
sometimes
there
are
better
iterator
names
than
i
j
and
k
for
instance
the
following
loops
find
which
users
belong
to
which
clubs
for
int
i
i
clubs
size
i
for
int
j
j
clubs
i
members
size
j
for
int
k
k
users
size
k
if
clubs
i
members
k
users
j
cout
user
j
is
in
club
i
endl
in
the
if
statement
members
and
users
are
using
the
wrong
index
bugs
like
these
are
hard
to
spot
because
that
line
of
code
seems
fine
in
isolation
if
clubs
i
members
k
users
j
in
this
case
using
more
precise
names
may
have
helped
instead
of
naming
the
loop
indexes
i
j
k
another
choice
would
be
club
i
members
i
users
i
or
more
succinctly
ci
mi
ui
this
approach
would
help
the
bug
stand
out
more
if
clubs
ci
members
ui
users
mi
bug
first
letters
don
t
match
up
when
used
correctly
the
first
letter
of
the
index
would
match
the
first
letter
of
the
array
if
clubs
ci
members
mi
users
ui
ok
first
letters
match
the
verdict
on
generic
names
as
you
ve
seen
there
are
some
situations
where
generic
names
are
useful
advice
if
you
re
going
to
use
a
generic
name
like
tmp
it
or
retval
have
a
good
reason
for
doing
so
a
lot
of
the
time
they
re
overused
out
of
pure
laziness
this
is
understandable
when
nothing
better
comes
to
mind
it
s
easier
to
just
use
a
meaningless
name
like
foo
and
move
on
but
if
you
get
in
the
habit
of
taking
an
extra
few
seconds
to
come
up
with
a
good
name
you
ll
find
your
naming
muscle
builds
quickly
chapter
two
prefer
concrete
names
over
abstract
names
when
naming
a
variable
function
or
other
element
describe
it
concretely
rather
than
abstractly
for
example
suppose
you
have
an
internal
method
named
servercanstart
which
tests
whether
the
server
can
listen
on
a
given
tcp
ip
port
the
name
servercanstart
is
somewhat
abstract
though
a
more
concrete
name
would
be
canlistenonport
this
name
directly
describes
what
the
method
will
do
the
next
two
examples
illustrate
this
concept
in
more
depth
example
disallow
evil
constructors
here
s
an
example
from
the
codebase
at
google
in
c
if
you
don
t
define
a
copy
constructor
or
assignment
operator
for
your
class
a
default
is
provided
although
handy
these
methods
packing
information
into
names
can
easily
lead
to
memory
leaks
and
other
mishaps
because
they
re
executed
behind
the
scenes
in
places
you
might
not
have
realized
as
a
result
google
has
a
convention
to
disallow
these
evil
constructors
using
a
macro
class
classname
private
disallow
evil
constructors
classname
public
this
macro
was
defined
as
define
disallow
evil
constructors
classname
classname
const
classname
void
operator
const
classname
by
placing
this
macro
in
the
private
section
of
a
class
these
two
methods
become
private
so
that
they
can
t
be
used
even
accidentally
the
name
disallow
evil
constructors
isn
t
very
good
though
the
use
of
the
word
evil
conveys
an
overly
strong
stance
on
a
debatable
issue
more
important
it
isn
t
clear
what
that
macro
is
disallowing
it
disallows
the
operator
method
and
that
isn
t
even
a
constructor
the
name
was
used
for
years
but
was
eventually
replaced
with
something
less
provocative
and
more
concrete
define
disallow
copy
and
assign
classname
example
run
locally
one
of
our
programs
had
an
optional
command
line
flag
named
run
locally
this
flag
would
cause
the
program
to
print
extra
debugging
information
but
run
more
slowly
the
flag
was
typically
used
when
testing
on
a
local
machine
like
a
laptop
but
when
the
program
was
running
on
a
remote
server
performance
was
important
so
the
flag
wasn
t
used
you
can
see
how
the
name
run
locally
came
about
but
it
has
some
problems
a
new
member
of
the
team
didn
t
know
what
it
did
he
would
use
it
when
running
locally
imagine
that
but
he
didn
t
know
why
it
was
needed
occasionally
we
needed
to
print
debugging
information
while
the
program
ran
remotely
passing
run
locally
to
a
program
that
is
running
remotely
looks
funny
and
it
s
just
confusing
sometimes
we
would
run
a
performance
test
locally
and
didn
t
want
the
logging
slowing
it
down
so
we
wouldn
t
use
run
locally
the
problem
is
that
run
locally
was
named
after
the
circumstance
where
it
was
typically
used
instead
a
flag
name
like
extra
logging
would
be
more
direct
and
explicit
chapter
two
but
what
if
run
locally
needs
to
do
more
than
just
extra
logging
for
instance
suppose
that
it
needs
to
set
up
and
use
a
special
local
database
now
the
name
run
locally
seems
more
tempting
because
it
can
control
both
of
these
at
once
but
using
it
for
that
purpose
would
be
picking
a
name
because
it
s
vague
and
indirect
which
is
probably
not
a
good
idea
the
better
solution
is
to
create
a
second
flag
named
use
local
database
even
though
you
have
to
use
two
flags
now
these
flags
are
much
more
explicit
they
don
t
try
to
smash
two
orthogonal
ideas
into
one
and
they
give
you
the
option
of
using
just
one
and
not
the
other
attaching
extra
information
to
a
name
packing
information
into
names
as
we
mentioned
before
a
variable
s
name
is
like
a
tiny
comment
even
though
there
isn
t
much
room
any
extra
information
you
squeeze
into
a
name
will
be
seen
every
time
the
variable
is
seen
so
if
there
s
something
very
important
about
a
variable
that
the
reader
must
know
it
s
worth
attaching
an
extra
word
to
the
name
for
example
suppose
you
had
a
variable
that
contained
a
hexadecimal
string
string
id
example
af
ef
cd
you
might
want
to
name
it
hex
id
instead
if
it
s
important
for
the
reader
to
remember
the
id
s
format
values
with
units
if
your
variable
is
a
measurement
such
as
an
amount
of
time
or
a
number
of
bytes
it
s
helpful
to
encode
the
units
into
the
variable
s
name
for
example
here
is
some
javascript
code
that
measures
the
load
time
of
a
web
page
var
start
new
date
gettime
top
of
the
page
var
elapsed
new
date
gettime
start
bottom
of
the
page
document
writeln
load
time
was
elapsed
seconds
there
is
nothing
obviously
wrong
with
this
code
but
it
doesn
t
work
because
gettime
returns
milliseconds
not
seconds
by
appending
ms
to
our
variables
we
can
make
everything
more
explicit
var
start
ms
new
date
gettime
top
of
the
page
var
elapsed
ms
new
date
gettime
start
ms
bottom
of
the
page
document
writeln
load
time
was
elapsed
ms
seconds
besides
time
there
are
plenty
of
other
units
that
come
up
in
programming
here
is
a
table
of
unitless
function
parameters
and
better
versions
that
include
the
units
function
parameter
renaming
parameter
to
encode
units
start
int
delay
delay
delay
secs
createcache
int
size
size
size
mb
throttledownload
float
limit
limit
max
kbps
rotate
float
angle
angle
degrees
cw
encoding
other
important
attributes
this
technique
of
attaching
extra
information
to
a
name
isn
t
limited
to
values
with
units
you
should
do
it
any
time
there
s
something
dangerous
or
surprising
about
the
variable
chapter
two
for
example
many
security
exploits
come
from
not
realizing
that
some
data
your
program
receives
is
not
yet
in
a
safe
state
for
this
you
might
want
to
use
variable
names
like
untrustedurl
or
unsafemessagebody
after
calling
functions
that
cleanse
the
unsafe
input
the
resulting
variables
might
be
trustedurl
or
safemessagebody
the
following
table
shows
additional
examples
of
when
extra
information
should
be
encoded
in
the
name
situation
variable
name
better
name
a
password
is
in
plaintext
and
should
be
encrypted
before
further
processing
password
plaintext
password
a
user
provided
comment
that
needs
escaping
before
being
displayed
comment
unescaped
comment
bytes
of
html
have
been
converted
to
utf
html
html
utf
incoming
data
has
been
url
encoded
data
data
urlenc
you
shouldn
t
use
attributes
like
unescaped
or
utf
for
every
variable
in
your
program
they
re
most
important
in
places
where
a
bug
can
easily
sneak
in
if
someone
mistakes
what
the
variable
is
especially
if
the
consequences
are
dire
as
with
a
security
bug
essentially
if
it
s
a
critical
thing
to
understand
put
it
in
the
name
is
this
hungarian
notation
hungarian
notation
is
a
system
of
naming
used
widely
inside
microsoft
it
encodes
the
type
of
every
variable
into
the
name
s
prefix
here
are
some
examples
name
meaning
plast
a
pointer
p
to
the
last
element
in
some
data
structure
pszbuffer
a
pointer
p
to
a
zero
terminated
z
string
s
buffer
cch
a
count
c
of
characters
ch
mpcopx
a
map
m
from
a
pointer
to
a
color
pco
to
a
pointer
to
an
x
axis
length
px
it
is
indeed
an
example
of
attaching
attributes
to
names
but
it
s
a
more
formal
and
strict
system
focused
on
encoding
a
specific
set
of
attributes
what
we
re
advocating
in
this
section
is
a
broader
more
informal
system
identify
any
crucial
attributes
of
a
variable
and
encode
them
legibly
if
they
re
needed
at
all
you
might
call
it
english
notation
packing
information
into
names
how
long
should
a
name
be
when
picking
a
good
name
there
s
an
implicit
constraint
that
the
name
shouldn
t
be
too
long
no
one
likes
to
work
with
identifiers
like
this
newnavigationcontrollerwrappingviewcontrollerfordatasourceofclass
the
longer
a
name
is
the
harder
it
is
to
remember
and
the
more
space
it
consumes
on
the
screen
possibly
causing
extra
lines
to
wrap
on
the
other
hand
programmers
can
take
this
advice
too
far
using
only
single
word
or
singleletter
names
so
how
should
you
manage
this
trade
off
how
do
you
decide
between
naming
a
variable
d
days
or
days
since
last
update
this
decision
is
a
judgment
call
whose
best
answer
depends
on
exactly
how
that
variable
is
being
used
but
here
are
some
guidelines
to
help
you
decide
shorter
names
are
okay
for
shorter
scope
when
you
go
on
a
short
vacation
you
typically
pack
less
luggage
than
if
you
go
on
a
long
vacation
similarly
identifiers
that
have
a
small
scope
how
many
other
lines
of
code
can
see
this
name
don
t
need
to
carry
as
much
information
that
is
you
can
get
away
with
shorter
names
because
all
that
information
what
type
the
variable
is
its
initial
value
how
it
s
destroyed
is
easy
to
see
chapter
two
if
debug
map
string
int
m
lookupnamesnumbers
m
print
m
even
though
m
doesn
t
pack
any
information
it
s
not
a
problem
because
the
reader
already
has
all
the
information
she
needs
to
understand
this
code
however
suppose
m
were
a
class
member
or
a
global
variable
and
you
saw
this
snippet
of
code
lookupnamesnumbers
m
print
m
this
code
is
much
less
readable
as
it
s
unclear
what
the
type
or
purpose
of
m
is
so
if
an
identifier
has
a
large
scope
the
name
needs
to
carry
enough
information
to
make
it
clear
typing
long
names
not
a
problem
anymore
there
are
many
good
reasons
to
avoid
long
names
but
they
re
harder
to
type
is
no
longer
one
of
them
every
programming
text
editor
we
ve
seen
has
word
completion
built
in
surprisingly
most
programmers
aren
t
aware
of
this
feature
if
you
haven
t
tried
this
feature
on
your
editor
yet
please
put
this
book
down
right
now
and
try
it
type
the
first
few
characters
of
the
name
trigger
the
word
completion
command
see
below
if
the
completed
word
is
not
correct
keep
triggering
the
command
until
the
correct
name
appears
it
s
surprisingly
accurate
it
works
on
any
type
of
file
in
any
language
and
it
works
for
any
token
even
if
you
re
typing
a
comment
editor
command
vi
ctrl
p
emacs
meta
hit
esc
then
eclipse
alt
intellij
idea
alt
textmate
esc
acronyms
and
abbreviations
programmers
sometimes
resort
to
acronyms
and
abbreviations
to
keep
their
names
small
for
example
naming
a
class
bemanager
instead
of
backendmanager
is
this
shrinkage
worth
the
potential
confusion
packing
information
into
names
in
our
experience
project
specific
abbreviations
are
usually
a
bad
idea
they
appear
cryptic
and
intimidating
to
those
new
to
the
project
given
enough
time
they
even
start
to
appear
cryptic
and
intimidating
to
the
authors
so
our
rule
of
thumb
is
would
a
new
teammate
understand
what
the
name
means
if
so
then
it
s
probably
okay
for
example
it
s
fairly
common
for
programmers
to
use
eval
instead
of
evaluation
doc
instead
of
document
str
instead
of
string
so
a
new
teammate
seeing
formatstr
will
probably
understand
what
that
means
however
he
or
she
probably
won
t
understand
what
a
bemanager
is
throwing
out
unneeded
words
sometimes
words
inside
a
name
can
be
removed
without
losing
any
information
at
all
for
instance
instead
of
converttostring
the
name
tostring
is
smaller
and
doesn
t
lose
any
real
information
similarly
instead
of
doserveloop
the
name
serveloop
is
just
as
clear
use
name
formatting
to
convey
meaning
the
way
you
use
underscores
dashes
and
capitalization
can
also
pack
more
information
in
a
name
for
example
here
is
some
c
code
that
follows
the
formatting
conventions
used
for
google
open
source
projects
static
const
int
kmaxopenfiles
class
logreader
public
void
openfile
string
local
file
private
int
offset
disallow
copy
and
assign
logreader
having
different
formats
for
different
entities
is
like
a
form
of
syntax
highlighting
it
helps
you
read
the
code
more
easily
most
of
the
formatting
in
this
example
is
pretty
common
using
camelcase
for
class
names
and
using
lower
separated
for
variable
names
but
some
of
the
other
conventions
may
have
surprised
you
for
instance
constant
values
are
of
the
form
kconstantname
instead
of
constant
name
this
style
has
the
benefit
of
being
easily
distinguished
from
define
macros
which
are
macro
name
by
convention
class
member
variables
are
like
normal
variables
but
must
end
with
an
underscore
like
offset
at
first
this
convention
may
seem
strange
but
being
able
to
instantly
distinguish
chapter
two
members
from
other
variables
is
very
handy
for
instance
if
you
re
glancing
through
the
code
of
a
large
method
and
see
the
line
stats
clear
you
might
ordinarily
wonder
does
stats
belong
to
this
class
is
this
code
changing
the
internal
state
of
the
class
if
the
member
convention
is
used
you
can
quickly
conclude
no
stats
must
be
a
local
variable
otherwise
it
would
be
named
stats
other
formatting
conventions
depending
on
the
context
of
your
project
or
language
there
may
be
other
formatting
conventions
you
can
use
to
make
names
contain
more
information
for
instance
in
javascript
the
good
parts
douglas
crockford
o
reilly
the
author
suggests
that
constructors
functions
intended
to
be
called
with
new
should
be
capitalized
and
that
ordinary
functions
should
start
with
a
lowercase
letter
var
x
new
datepicker
var
y
pageheight
datepicker
is
a
constructor
function
pageheight
is
an
ordinary
function
here
s
another
javascript
example
when
calling
the
jquery
library
function
whose
name
is
the
single
character
a
useful
convention
is
to
prefix
jquery
results
with
as
well
var
all
images
img
all
images
is
a
jquery
object
var
height
height
is
not
throughout
the
code
it
will
be
clear
that
all
images
is
a
jquery
result
object
here
s
a
final
example
this
time
about
html
css
when
giving
an
html
tag
an
id
or
class
attribute
both
underscores
and
dashes
are
valid
characters
to
use
in
the
value
one
possible
convention
is
to
use
underscores
to
separate
words
in
ids
and
dashes
to
separate
words
in
classes
div
id
middle
column
class
main
content
whether
you
decide
to
use
conventions
like
these
is
up
to
you
and
your
team
but
whichever
system
you
use
be
consistent
across
your
project
summary
the
single
theme
for
this
chapter
is
pack
information
into
your
names
by
this
we
mean
that
the
reader
can
extract
a
lot
of
information
just
from
reading
the
name
here
are
some
specific
tips
we
covered
use
specific
words
for
example
instead
of
get
words
like
fetch
or
download
might
be
better
depending
on
the
context
avoid
generic
names
like
tmp
and
retval
unless
there
s
a
specific
reason
to
use
them
packing
information
into
names
use
concrete
names
that
describe
things
in
more
detail
the
name
servercanstart
is
vague
compared
to
canlistenonport
attach
important
details
to
variable
names
for
example
append
ms
to
a
variable
whose
value
is
in
milliseconds
or
prepend
raw
to
an
unprocessed
variable
that
needs
escaping
use
longer
names
for
larger
scopes
don
t
use
cryptic
one
or
two
letter
names
for
variables
that
span
multiple
screens
shorter
names
are
better
for
variables
that
span
only
a
few
lines
use
capitalization
underscores
and
so
on
in
a
meaningful
way
for
example
you
can
append
to
class
members
to
distinguish
them
from
local
variables
chapter
two
chapter
three
names
that
can
t
be
misconstrued
in
the
previous
chapter
we
covered
how
to
put
a
lot
of
information
into
your
names
in
this
chapter
we
focus
on
a
different
topic
watching
out
for
names
that
can
be
misunderstood
key
idea
actively
scrutinize
your
names
by
asking
yourself
what
other
meanings
could
someone
interpret
from
this
name
really
try
to
be
creative
here
actively
seeking
wrong
interpretations
this
step
will
help
you
spot
those
ambiguous
names
so
you
can
change
them
for
the
examples
in
this
chapter
we
re
going
to
think
aloud
as
we
discuss
the
misinterpretations
of
each
name
we
see
and
then
pick
better
names
example
filter
suppose
you
re
writing
code
to
manipulate
a
set
of
database
results
results
database
all
objects
filter
year
what
does
results
now
contain
objects
whose
year
is
objects
whose
year
is
not
the
problem
is
that
filter
is
an
ambiguous
word
it
s
unclear
whether
it
means
to
pick
out
or
to
get
rid
of
it
s
best
to
avoid
the
name
filter
because
it
s
so
easily
misconstrued
if
you
want
to
pick
out
a
better
name
is
select
if
you
want
to
get
rid
of
a
better
name
is
exclude
example
clip
text
length
suppose
you
have
a
function
that
clips
the
contents
of
a
paragraph
cuts
off
the
end
of
the
text
and
appends
def
clip
text
length
there
are
two
ways
you
can
imagine
how
clip
behaves
it
removes
length
from
the
end
it
truncates
to
a
maximum
length
the
second
way
truncation
is
most
likely
but
you
never
know
for
sure
rather
than
leave
your
reader
with
any
nagging
doubt
it
would
be
better
to
name
the
function
truncate
text
length
chapter
three
however
the
parameter
name
length
is
also
to
blame
if
it
were
max
length
that
would
make
it
even
more
clear
but
we
re
still
not
done
the
name
max
length
still
leaves
multiple
interpretations
a
number
of
bytes
a
number
of
characters
a
number
of
words
as
you
saw
in
the
previous
chapter
this
is
a
case
where
the
units
should
be
attached
to
the
name
in
this
case
we
mean
number
of
characters
so
instead
of
max
length
it
should
be
max
chars
prefer
min
and
max
for
inclusive
limits
let
s
say
your
shopping
cart
application
needs
to
stop
people
from
buying
more
than
items
at
once
cart
too
big
limit
if
shopping
cart
num
items
cart
too
big
limit
error
too
many
items
in
cart
this
code
has
a
classic
off
by
one
bug
we
could
easily
fix
it
by
changing
to
if
shopping
cart
num
items
cart
too
big
limit
or
by
redefining
cart
too
big
limit
to
but
the
root
problem
is
that
cart
too
big
limit
is
an
ambiguous
name
it
s
not
clear
whether
you
mean
up
to
or
up
to
and
including
advice
the
clearest
way
to
name
a
limit
is
to
put
max
or
min
in
front
of
the
thing
being
limited
in
this
case
the
name
should
be
max
items
in
cart
the
new
code
is
simple
and
clear
max
items
in
cart
if
shopping
cart
num
items
max
items
in
cart
error
too
many
items
in
cart
names
that
can
t
be
misconstrued
prefer
first
and
last
for
inclusive
ranges
here
is
another
example
where
you
can
t
tell
if
it
s
up
to
or
up
to
and
including
print
integer
range
start
stop
does
this
print
or
or
something
else
although
start
is
a
reasonable
parameter
name
stop
can
be
interpreted
in
multiple
ways
here
for
inclusive
ranges
likes
these
where
the
range
should
include
both
end
points
a
good
choice
is
first
last
for
instance
set
printkeys
first
bart
last
maggie
unlike
stop
the
word
last
is
clearly
inclusive
in
addition
to
first
last
the
names
min
max
may
also
work
for
inclusive
ranges
assuming
they
sound
right
in
that
context
prefer
begin
and
end
for
inclusive
exclusive
ranges
in
practice
it
s
often
more
convenient
to
use
inclusive
exclusive
ranges
for
example
if
you
want
to
print
all
the
events
that
happened
on
october
it
s
easier
to
write
printeventsinrange
oct
am
oct
am
than
it
is
to
write
printeventsinrange
oct
am
oct
pm
so
what
is
a
good
pair
of
names
for
these
parameters
well
the
typical
programming
convention
for
naming
an
inclusive
exclusive
range
is
begin
end
but
the
word
end
is
a
little
ambiguous
for
example
in
the
sentence
i
m
at
the
end
of
the
book
the
end
is
inclusive
unfortunately
english
doesn
t
have
a
succinct
word
for
just
past
the
last
value
chapter
three
because
begin
end
is
so
idiomatic
at
least
it
s
used
this
way
in
the
standard
library
for
c
and
most
places
where
an
array
needs
to
be
sliced
this
way
it
s
the
best
option
naming
booleans
when
picking
a
name
for
a
boolean
variable
or
a
function
that
returns
a
boolean
be
sure
it
s
clear
what
true
and
false
really
mean
here
s
a
dangerous
example
bool
read
password
true
depending
on
how
you
read
it
no
pun
intended
there
are
two
very
different
interpretations
we
need
to
read
the
password
the
password
has
already
been
read
in
this
case
it
s
best
to
avoid
the
word
read
and
name
it
need
password
or
user
is
authenticated
instead
in
general
adding
words
like
is
has
can
or
should
can
make
booleans
more
clear
for
example
a
function
named
spaceleft
sounds
like
it
might
return
a
number
if
it
were
meant
to
return
a
boolean
a
better
name
would
be
hasspaceleft
finally
it
s
best
to
avoid
negated
terms
in
a
name
for
example
instead
of
bool
disable
ssl
false
it
would
be
easier
to
read
and
more
compact
to
say
bool
use
ssl
true
matching
expectations
of
users
some
names
are
misleading
because
the
user
has
a
preconceived
idea
of
what
the
name
means
even
though
you
mean
something
else
in
these
cases
it
s
best
to
just
give
in
and
change
the
name
so
that
it
s
not
misleading
example
get
many
programmers
are
used
to
the
convention
that
methods
starting
with
get
are
lightweight
accessors
that
simply
return
an
internal
member
going
against
this
convention
is
likely
to
mislead
those
users
names
that
can
t
be
misconstrued
here
s
an
example
in
java
of
what
not
to
do
public
class
statisticscollector
public
void
addsample
double
x
public
double
getmean
iterate
through
all
samples
and
return
total
num
samples
in
this
case
the
implementation
of
getmean
is
to
iterate
over
past
data
and
calculate
the
mean
on
the
fly
this
step
might
be
very
expensive
if
there
s
a
lot
of
data
but
an
unsuspecting
programmer
might
call
getmean
carelessly
assuming
that
it
s
an
inexpensive
call
instead
the
method
should
be
renamed
to
something
like
computemean
which
sounds
more
like
an
expensive
operation
alternatively
it
should
be
reimplemented
to
indeed
be
a
lightweight
operation
example
list
size
here
s
an
example
from
the
c
standard
library
the
following
code
was
the
cause
of
a
very
difficult
to
find
bug
that
made
one
of
our
servers
slow
down
to
a
crawl
void
shrinklist
list
node
list
int
max
size
while
list
size
max
size
freenode
list
back
list
pop
back
the
bug
is
that
the
author
didn
t
know
that
list
size
is
an
o
n
operation
it
counts
through
the
linked
list
node
by
node
instead
of
just
returning
a
precalculated
count
which
makes
shrinklist
an
o
n
operation
the
code
is
technically
correct
and
in
fact
passed
all
our
unit
tests
but
when
shrinklist
was
called
on
a
list
with
a
million
elements
it
took
over
an
hour
to
finish
maybe
you
re
thinking
that
s
the
caller
s
fault
he
or
she
should
have
read
the
documentation
more
carefully
that
s
true
but
in
this
case
the
fact
that
list
size
isn
t
a
constant
time
operation
is
surprising
all
of
the
other
containers
in
c
have
a
constant
time
size
method
had
size
been
named
countsize
or
countelements
the
same
mistake
would
be
less
likely
the
writers
of
the
c
standard
library
probably
wanted
to
name
the
method
size
to
match
all
the
other
containers
like
vector
and
map
but
because
they
did
programmers
easily
mistake
it
to
be
a
fast
operation
the
way
it
is
for
other
containers
thankfully
the
latest
c
standard
now
mandates
size
to
be
o
chapter
three
who
s
the
wizard
a
while
ago
one
of
the
authors
was
installing
the
openbsd
operating
system
during
the
disk
formatting
step
a
complicated
menu
appeared
asking
for
disk
parameters
one
of
the
options
was
to
go
to
wizard
mode
he
was
relieved
to
find
this
user
friendly
option
and
selected
it
to
his
dismay
it
dropped
the
installer
into
a
low
level
prompt
waiting
for
manual
disk
formatting
commands
with
no
clear
way
to
get
out
of
it
evidently
wizard
meant
you
were
the
wizard
example
evaluating
multiple
name
candidates
when
deciding
on
a
good
name
you
might
have
multiple
candidates
that
you
re
considering
it
s
common
to
debate
the
merits
of
each
name
in
your
head
before
settling
on
the
final
choice
the
following
example
illustrates
this
critiquing
process
high
traffic
websites
often
use
experiments
to
test
whether
a
change
to
the
website
improves
business
here
s
an
example
of
a
config
file
that
controls
some
experiments
experiment
id
description
increase
font
size
to
pt
traffic
fraction
each
experiment
is
defined
by
about
attribute
value
pairs
unfortunately
when
defining
another
experiment
that
s
very
similar
you
have
to
copy
and
paste
most
of
those
lines
experiment
id
description
increase
font
size
to
pt
other
lines
identical
to
experiment
id
suppose
we
want
to
fix
this
situation
by
introducing
a
way
to
have
one
experiment
reuse
the
properties
from
another
this
is
the
prototype
inheritance
pattern
the
end
result
is
that
you
would
type
something
like
experiment
id
the
other
experiment
id
i
want
to
reuse
change
any
properties
as
needed
the
question
is
what
should
the
other
experiment
id
i
want
to
reuse
really
be
named
here
are
four
names
to
consider
template
reuse
copy
inherit
names
that
can
t
be
misconstrued
any
of
these
names
make
sense
to
us
because
we
re
the
ones
adding
this
new
feature
to
the
config
language
but
we
have
to
imagine
how
the
name
will
sound
to
someone
who
comes
across
the
code
and
doesn
t
know
about
this
feature
so
let
s
analyze
each
name
thinking
of
ways
someone
could
misinterpret
it
let
s
imagine
using
the
name
template
experiment
id
template
template
has
a
couple
problems
first
it
s
not
clear
whether
it
s
saying
i
am
a
template
or
i
am
using
this
other
template
second
a
template
is
often
something
abstract
that
must
be
filled
in
before
it
is
concrete
someone
might
think
a
templated
experiment
isn
t
a
real
experiment
overall
template
is
just
too
vague
in
this
situation
how
about
reuse
experiment
id
reuse
reuse
is
an
okay
word
but
as
written
someone
might
think
it
s
saying
this
experiment
can
be
reused
at
most
times
changing
the
name
to
reuse
id
would
help
but
a
confused
reader
might
think
reuse
id
means
my
id
for
reuse
is
let
s
consider
copy
experiment
id
copy
copy
is
a
good
word
but
by
itself
copy
seems
like
it
might
be
saying
copy
this
experiment
times
or
this
is
the
th
copy
of
something
to
make
it
clear
that
this
term
refers
to
another
experiment
we
could
change
the
name
to
copy
experiment
this
is
probably
the
best
name
so
far
but
now
let
s
consider
inherit
experiment
id
inherit
the
word
inherit
is
familiar
to
most
programmers
and
it
s
understood
that
further
modifications
are
made
after
inheritance
with
class
inheritance
you
get
all
the
methods
and
members
of
another
class
and
then
modify
them
or
add
more
even
in
real
life
when
you
inherit
possessions
from
a
relative
it
s
understood
that
you
might
sell
them
or
own
other
things
yourself
but
again
let
s
make
it
clear
that
we
re
inheriting
from
another
experiment
we
can
improve
the
name
to
inherit
from
or
even
inherit
from
experiment
id
chapter
three
overall
copy
experiment
and
inherit
from
experiment
id
are
the
best
names
because
they
most
clearly
describe
what
s
happening
and
are
least
likely
to
be
misunderstood
summary
the
best
names
are
ones
that
can
t
be
misconstrued
the
person
reading
your
code
will
understand
it
the
way
you
meant
it
and
no
other
way
unfortunately
a
lot
of
english
words
are
ambiguous
when
it
comes
to
programming
such
as
filter
length
and
limit
before
you
decide
on
a
name
play
devil
s
advocate
and
imagine
how
your
name
might
be
misunderstood
the
best
names
are
resistant
to
misinterpretation
when
it
comes
to
defining
an
upper
or
lower
limit
for
a
value
max
and
min
are
good
prefixes
to
use
for
inclusive
ranges
first
and
last
are
good
for
inclusive
exclusive
ranges
begin
and
end
are
best
because
they
re
the
most
idiomatic
when
naming
a
boolean
use
words
like
is
and
has
to
make
it
clear
that
it
s
a
boolean
avoid
negated
terms
e
g
disable
ssl
beware
of
users
expectations
about
certain
words
for
example
users
may
expect
get
or
size
to
be
lightweight
methods
names
that
can
t
be
misconstrued
chapter
four
aesthetics
a
lot
of
thought
goes
into
the
layout
of
a
magazine
the
length
of
the
paragraphs
the
width
of
the
columns
the
order
of
the
articles
and
what
goes
on
the
cover
a
good
magazine
makes
it
easy
to
skip
around
from
page
to
page
but
also
easy
to
read
straight
through
good
source
code
should
be
just
as
easy
on
the
eyes
in
this
chapter
we
ll
show
how
good
use
of
spacing
alignment
and
ordering
can
make
your
code
easier
to
read
specifically
there
are
three
principles
we
use
use
consistent
layout
with
patterns
the
reader
can
get
used
to
make
similar
code
look
similar
group
related
lines
of
code
into
blocks
aesthetics
vs
design
in
this
chapter
we
re
concerned
only
with
simple
aesthetic
improvements
you
can
make
to
your
code
these
types
of
changes
are
easy
to
make
and
often
improve
readability
quite
a
bit
there
are
times
when
larger
refactoring
of
your
code
such
as
splitting
out
new
functions
or
classes
can
help
even
more
our
view
is
that
good
aesthetics
and
good
design
are
independent
ideas
ideally
you
should
strive
for
both
why
do
aesthetics
matter
chapter
four
imagine
if
you
had
to
use
this
class
class
statskeeper
public
a
class
for
keeping
track
of
a
series
of
doubles
void
add
double
d
and
methods
for
quick
statistics
about
them
private
int
count
how
many
so
far
public
double
average
private
double
minimum
list
double
past
items
double
maximum
it
would
take
you
a
lot
longer
to
understand
it
than
if
you
had
this
cleaner
version
instead
a
class
for
keeping
track
of
a
series
of
doubles
and
methods
for
quick
statistics
about
them
class
statskeeper
public
void
add
double
d
double
average
private
list
double
past
items
int
count
how
many
so
far
double
minimum
double
maximum
obviously
it
s
easier
to
work
with
code
that
s
aesthetically
pleasing
if
you
think
about
it
most
of
your
time
programming
is
spent
looking
at
code
the
faster
you
can
skim
through
your
code
the
easier
it
is
for
everyone
to
use
it
rearrange
line
breaks
to
be
consistent
and
compact
suppose
you
were
writing
java
code
to
evaluate
how
your
program
behaves
under
various
network
connection
speeds
you
have
a
tcpconnectionsimulator
that
takes
four
parameters
in
the
constructor
the
speed
of
the
connection
kbps
the
average
latency
ms
the
jitter
of
the
latency
ms
the
packet
loss
percentage
aesthetics
your
code
needed
three
different
tcpconnectionsimulator
instances
public
class
performancetester
public
static
final
tcpconnectionsimulator
wifi
new
tcpconnectionsimulator
kbps
millisecs
latency
jitter
packet
loss
public
static
final
tcpconnectionsimulator
t
fiber
new
tcpconnectionsimulator
kbps
millisecs
latency
jitter
packet
loss
public
static
final
tcpconnectionsimulator
cell
new
tcpconnectionsimulator
kbps
millisecs
latency
jitter
packet
loss
this
example
code
needed
a
lot
of
extra
line
breaks
to
fit
inside
an
character
limit
this
was
the
coding
standard
at
your
company
unfortunately
that
made
the
definition
of
t
fiber
look
different
from
its
neighbors
the
silhouette
of
this
code
is
odd
and
it
draws
attention
to
t
fiber
for
no
reason
this
doesn
t
follow
the
principle
that
similar
code
should
look
similar
to
make
the
code
look
more
consistent
we
could
introduce
extra
line
breaks
and
line
up
the
comments
while
we
re
at
it
public
class
performancetester
public
static
final
tcpconnectionsimulator
wifi
new
tcpconnectionsimulator
kbps
millisecs
latency
jitter
packet
loss
public
static
final
tcpconnectionsimulator
t
fiber
new
tcpconnectionsimulator
kbps
millisecs
latency
jitter
packet
loss
public
static
final
tcpconnectionsimulator
cell
new
tcpconnectionsimulator
kbps
millisecs
latency
jitter
packet
loss
chapter
four
this
code
has
a
nice
consistent
pattern
and
is
easier
to
scan
through
but
unfortunately
it
uses
a
lot
of
vertical
space
it
also
duplicates
each
comment
three
times
here
s
a
more
compact
way
to
write
the
class
public
class
performancetester
tcpconnectionsimulator
throughput
latency
jitter
packet
loss
kbps
ms
ms
percent
public
static
final
tcpconnectionsimulator
wifi
new
tcpconnectionsimulator
public
static
final
tcpconnectionsimulator
t
fiber
new
tcpconnectionsimulator
public
static
final
tcpconnectionsimulator
cell
new
tcpconnectionsimulator
we
ve
moved
the
comments
up
to
the
top
and
then
put
all
the
parameters
on
one
line
now
even
though
the
comment
isn
t
right
next
to
each
number
the
data
is
lined
up
in
a
more
compact
table
use
methods
to
clean
up
irregularity
suppose
you
had
a
personnel
database
that
provided
the
following
function
turn
a
partial
name
like
doug
adams
into
mr
douglas
adams
if
not
possible
error
is
filled
with
an
explanation
string
expandfullname
databaseconnection
dc
string
partial
name
string
error
and
this
function
was
tested
with
a
series
of
examples
databaseconnection
database
connection
string
error
assert
expandfullname
database
connection
mr
douglas
adams
assert
error
assert
expandfullname
database
connection
mr
jacob
brown
iii
assert
error
assert
expandfullname
database
connection
assert
error
no
match
found
assert
expandfullname
database
connection
assert
error
more
than
one
result
doug
adams
error
jake
brown
error
no
such
guy
error
john
error
this
code
is
not
aesthetically
pleasing
some
of
the
lines
are
so
long
that
they
wrap
to
the
next
line
the
silhouette
of
this
code
is
ugly
and
there
is
no
consistent
pattern
but
this
is
a
case
where
rearranging
the
line
breaks
can
only
do
so
much
the
bigger
problem
is
that
there
are
a
lot
of
repeated
strings
like
assert
expandfullname
database
connection
and
error
that
are
getting
in
the
way
to
really
improve
this
code
we
need
a
helper
method
so
the
code
can
look
like
this
aesthetics
checkfullname
doug
adams
mr
douglas
adams
checkfullname
jake
brown
mr
jake
brown
iii
checkfullname
no
such
guy
no
match
found
checkfullname
john
more
than
one
result
now
it
s
more
clear
that
there
are
four
tests
happening
each
with
different
parameters
even
though
all
the
dirty
work
is
inside
checkfullname
that
function
isn
t
so
bad
either
void
checkfullname
string
partial
name
string
expected
full
name
string
expected
error
database
connection
is
now
a
class
member
string
error
string
full
name
expandfullname
database
connection
partial
name
error
assert
error
expected
error
assert
full
name
expected
full
name
even
though
our
goal
was
just
to
make
the
code
more
aesthetically
pleasing
this
change
has
a
number
of
other
side
benefits
it
eliminates
a
lot
of
the
duplicated
code
from
before
making
the
code
more
compact
the
important
parts
of
each
test
case
the
names
and
error
strings
are
now
by
themselves
in
plain
sight
before
these
strings
were
interspersed
with
tokens
like
database
connection
and
error
which
made
it
hard
to
take
in
the
code
in
one
eyeful
adding
new
tests
should
be
much
easier
now
the
moral
of
the
story
is
that
making
code
look
pretty
often
results
in
more
than
just
surface
improvements
it
might
help
you
structure
your
code
better
use
column
alignment
when
helpful
straight
edges
and
columns
make
it
easier
for
readers
to
scan
through
text
sometimes
you
can
introduce
column
alignment
to
make
the
code
easier
to
read
for
example
in
the
previous
section
you
could
space
out
and
line
up
the
arguments
to
checkfullname
checkfullname
doug
adams
mr
douglas
adams
checkfullname
jake
brown
mr
jake
brown
iii
checkfullname
no
such
guy
checkfullname
john
no
match
found
more
than
one
result
in
this
code
it
s
easier
to
distinguish
the
second
and
third
arguments
to
checkfullname
here
is
a
simple
example
with
a
large
group
of
variable
definitions
extract
post
parameters
to
local
variables
details
request
post
get
details
location
request
post
get
location
phone
equest
post
get
phone
chapter
four
email
url
request
post
get
email
request
post
get
url
as
you
may
have
noticed
the
third
definition
has
a
typo
equest
instead
of
request
mistakes
like
these
are
more
pronounced
when
everything
is
lined
up
so
neatly
in
the
wget
codebase
the
available
command
line
options
more
than
of
them
were
listed
as
follows
commands
timeout
timestamping
tries
useproxy
useragent
null
opt
timestamping
opt
ntry
opt
use
proxy
null
cmd
spec
timeout
cmd
boolean
cmd
number
inf
cmd
boolean
cmd
spec
useragent
this
approach
made
the
list
very
easy
to
skim
through
and
jump
from
one
column
to
the
next
should
you
use
column
alignment
column
edges
provide
visual
handrails
that
make
it
easier
to
scan
through
it
s
a
good
example
of
make
similar
code
look
similar
but
some
programmers
don
t
like
it
one
reason
is
that
it
takes
more
work
to
set
up
and
maintain
the
alignment
another
reason
is
it
creates
a
larger
diff
when
making
changes
a
one
line
change
might
cause
five
other
lines
to
change
mostly
just
whitespace
our
advice
is
to
try
it
in
our
experience
it
doesn
t
take
as
much
work
as
programmers
fear
and
if
it
does
you
can
simply
stop
pick
a
meaningful
order
and
use
it
consistently
there
are
many
cases
where
the
order
of
code
doesn
t
affect
the
correctness
for
instance
these
five
variable
definitions
could
be
written
in
any
order
details
location
phone
email
url
request
post
get
details
request
post
get
location
request
post
get
phone
request
post
get
email
request
post
get
url
in
situations
like
this
it
s
helpful
to
put
them
in
some
meaningful
order
not
just
random
here
are
some
ideas
match
the
order
of
the
variables
to
the
order
of
the
input
fields
on
the
corresponding
html
form
aesthetics
order
them
from
most
important
to
least
important
order
them
alphabetically
whatever
the
order
you
should
use
the
same
order
throughout
your
code
it
would
be
confusing
to
change
the
order
later
on
if
if
if
if
if
details
phone
email
url
location
rec
details
rec
phone
rec
email
rec
url
rec
location
details
phone
email
url
location
hey
where
did
location
go
why
is
location
down
here
now
organize
declarations
into
blocks
the
brain
naturally
thinks
in
terms
of
groups
and
hierarchies
so
you
can
help
a
reader
quickly
digest
your
code
by
organizing
it
that
way
for
example
here
s
a
c
class
for
a
frontend
server
with
all
its
method
declarations
class
frontendserver
public
frontendserver
void
viewprofile
httprequest
request
void
opendatabase
string
location
string
user
void
saveprofile
httprequest
request
string
extractqueryparam
httprequest
request
string
param
void
replyok
httprequest
request
string
html
void
findfriends
httprequest
request
void
replynotfound
httprequest
request
string
error
void
closedatabase
string
location
frontendserver
this
code
isn
t
horrible
but
the
layout
certainly
doesn
t
help
the
reader
digest
all
those
methods
instead
of
listing
all
the
methods
in
one
giant
block
they
should
be
logically
organized
into
groups
like
this
class
frontendserver
public
frontendserver
frontendserver
handlers
void
viewprofile
httprequest
request
void
saveprofile
httprequest
request
void
findfriends
httprequest
request
request
reply
utilities
string
extractqueryparam
httprequest
request
string
param
void
replyok
httprequest
request
string
html
void
replynotfound
httprequest
request
string
error
chapter
four
database
helpers
void
opendatabase
string
location
string
user
void
closedatabase
string
location
this
version
is
much
easier
to
digest
it
s
also
easier
to
read
even
though
there
are
more
lines
of
code
the
reason
is
that
you
can
quickly
figure
out
the
four
high
level
sections
and
then
read
the
details
of
each
section
when
it
s
necessary
break
code
into
paragraphs
written
text
is
broken
into
paragraphs
for
a
number
of
reasons
it
s
a
way
to
group
similar
ideas
together
and
set
them
apart
from
other
ideas
it
provides
a
visual
stepping
stone
without
it
it
s
easy
to
lose
your
place
on
the
page
it
facilitates
navigation
from
one
paragraph
to
another
code
should
be
broken
into
paragraphs
for
the
same
reasons
for
example
no
one
likes
to
read
a
giant
lump
of
code
like
this
import
the
user
s
email
contacts
and
match
them
to
users
in
our
system
then
display
a
list
of
those
users
that
he
she
isn
t
already
friends
with
def
suggest
new
friends
user
email
password
friends
user
friends
friend
emails
set
f
email
for
f
in
friends
contacts
import
contacts
user
email
email
password
contact
emails
set
c
email
for
c
in
contacts
non
friend
emails
contact
emails
friend
emails
suggested
friends
user
objects
select
email
in
non
friend
emails
display
user
user
display
friends
friends
display
suggested
friends
suggested
friends
return
render
suggested
friends
html
display
it
may
not
be
obvious
but
this
function
goes
through
a
number
of
distinct
steps
so
it
would
be
especially
useful
to
break
up
those
lines
of
code
into
paragraphs
def
suggest
new
friends
user
email
password
get
the
user
s
friends
email
addresses
friends
user
friends
friend
emails
set
f
email
for
f
in
friends
import
all
email
addresses
from
this
user
s
email
account
contacts
import
contacts
user
email
email
password
contact
emails
set
c
email
for
c
in
contacts
find
matching
users
that
they
aren
t
already
friends
with
non
friend
emails
contact
emails
friend
emails
suggested
friends
user
objects
select
email
in
non
friend
emails
aesthetics
display
these
lists
on
the
page
display
user
user
display
friends
friends
display
suggested
friends
suggested
friends
return
render
suggested
friends
html
display
notice
that
we
also
added
a
summary
comment
to
each
paragraph
which
also
helps
the
reader
skim
through
the
code
see
chapter
knowing
what
to
comment
as
with
written
text
there
may
be
multiple
ways
to
break
the
code
up
and
programmers
may
prefer
longer
or
shorter
paragraphs
personal
style
versus
consistency
there
are
certain
aesthetic
choices
that
just
boil
down
to
personal
style
for
instance
where
the
open
brace
for
a
class
definition
should
go
class
logger
or
class
logger
if
one
of
these
styles
is
chosen
over
the
other
it
doesn
t
substantially
affect
the
readability
of
the
codebase
but
if
these
two
styles
are
mixed
throughout
the
code
it
does
affect
the
readability
we
ve
worked
on
many
projects
where
we
felt
like
the
team
was
using
the
wrong
style
but
we
followed
the
project
conventions
because
we
knew
that
consistency
is
far
more
important
key
idea
consistent
style
is
more
important
than
the
right
style
chapter
four
summary
everyone
prefers
to
read
code
that
s
aesthetically
pleasing
by
formatting
your
code
in
a
consistent
meaningful
way
you
make
it
easier
and
faster
to
read
here
are
specific
techniques
we
discussed
if
multiple
blocks
of
code
are
doing
similar
things
try
to
give
them
the
same
silhouette
aligning
parts
of
the
code
into
columns
can
make
code
easy
to
skim
through
if
code
mentions
a
b
and
c
in
one
place
don
t
say
b
c
and
a
in
another
pick
a
meaningful
order
and
stick
with
it
use
empty
lines
to
break
apart
large
blocks
into
logical
paragraphs
aesthetics
chapter
five
knowing
what
to
comment
the
goal
of
this
chapter
is
to
help
you
realize
what
you
should
be
commenting
you
might
think
the
purpose
of
commenting
is
to
explain
what
the
code
does
but
that
is
just
a
small
part
of
it
key
idea
the
purpose
of
commenting
is
to
help
the
reader
know
as
much
as
the
writer
did
when
you
re
writing
code
you
have
a
lot
of
valuable
information
in
your
head
when
other
people
read
your
code
that
information
is
lost
all
they
have
is
the
code
in
front
of
them
in
this
chapter
we
ll
show
you
many
examples
of
when
to
write
down
that
information
in
your
head
we
ve
left
out
the
more
mundane
points
about
commenting
instead
we
ve
focused
on
the
more
interesting
and
underserved
aspects
of
commenting
we
ve
organized
the
chapter
into
the
following
areas
knowing
what
not
to
comment
recording
your
thoughts
as
you
code
putting
yourself
in
the
readers
shoes
to
imagine
what
they
ll
need
to
know
chapter
five
what
not
to
comment
reading
a
comment
takes
time
away
from
reading
the
actual
code
and
each
comment
takes
up
space
on
the
screen
that
is
it
better
be
worth
it
so
where
do
you
draw
the
line
between
a
worthless
comment
and
a
good
one
all
of
the
comments
in
this
code
are
worthless
the
class
definition
for
account
class
account
public
constructor
account
set
the
profit
member
to
a
new
value
void
setprofit
double
profit
return
the
profit
from
this
account
double
getprofit
knowing
what
to
comment
these
comments
are
worthless
because
they
don
t
provide
any
new
information
or
help
the
reader
understand
the
code
better
key
idea
don
t
comment
on
facts
that
can
be
derived
quickly
from
the
code
itself
the
word
quickly
is
an
important
distinction
though
consider
the
comment
for
this
python
code
remove
everything
after
the
second
name
join
line
split
technically
this
comment
doesn
t
present
any
new
information
either
if
you
look
at
the
code
itself
you
ll
eventually
figure
out
what
it
s
doing
but
for
most
programmers
reading
the
commented
code
is
much
faster
than
understanding
the
code
without
it
don
t
comment
just
for
the
sake
of
commenting
some
professors
require
their
students
to
have
a
comment
for
each
function
in
their
homework
code
as
a
result
some
programmers
feel
guilty
about
leaving
a
function
naked
without
comments
and
end
up
rewriting
the
function
s
name
and
arguments
in
sentence
form
find
the
node
in
the
given
subtree
with
the
given
name
using
the
given
depth
node
findnodeinsubtree
node
subtree
string
name
int
depth
chapter
five
this
one
falls
into
the
worthless
comments
category
the
function
s
declaration
and
the
comment
are
virtually
the
same
this
comment
should
be
either
removed
or
improved
if
you
want
to
have
a
comment
here
it
might
as
well
elaborate
on
more
important
details
find
a
node
with
the
given
name
or
return
null
if
depth
only
subtree
is
inspected
if
depth
n
only
subtree
and
n
levels
below
are
inspected
node
findnodeinsubtree
node
subtree
string
name
int
depth
don
t
comment
bad
names
fix
the
names
instead
a
comment
shouldn
t
have
to
make
up
for
a
bad
name
for
example
here
s
an
innocentlooking
comment
for
a
function
named
cleanreply
enforce
limits
on
the
reply
as
stated
in
the
request
such
as
the
number
of
items
returned
or
total
byte
size
etc
void
cleanreply
request
request
reply
reply
most
of
the
comment
is
simply
explaining
what
clean
means
instead
the
phrase
enforce
limits
should
be
moved
into
the
function
name
make
sure
reply
meets
the
count
byte
etc
limits
from
the
request
void
enforcelimitsfromrequest
request
request
reply
reply
this
function
name
is
more
self
documenting
a
good
name
is
better
than
a
good
comment
because
it
will
be
seen
everywhere
the
function
is
used
here
is
another
example
of
a
comment
for
a
poorly
named
function
releases
the
handle
for
this
key
this
doesn
t
modify
the
actual
registry
void
deleteregistry
registrykey
key
the
name
deleteregistry
sounds
like
a
dangerous
function
it
deletes
the
registry
the
comment
this
doesn
t
modify
the
actual
registry
is
trying
to
clear
up
the
confusion
instead
we
could
use
a
more
self
documenting
name
like
void
releaseregistryhandle
registrykey
key
in
general
you
don
t
want
crutch
comments
comments
that
are
trying
to
make
up
for
the
unreadability
of
the
code
coders
often
state
this
rule
as
good
code
bad
code
good
comments
recording
your
thoughts
now
that
you
know
what
not
to
comment
let
s
discuss
what
should
be
commented
but
often
isn
t
a
lot
of
good
comments
can
come
out
of
simply
recording
your
thoughts
that
is
the
important
thoughts
you
had
as
you
were
writing
the
code
knowing
what
to
comment
include
director
commentary
movies
often
have
a
director
commentary
track
where
the
filmmakers
give
their
insights
and
tell
stories
to
help
you
understand
how
the
film
was
made
similarly
you
should
include
comments
to
record
valuable
insights
about
the
code
here
s
an
example
surprisingly
a
binary
tree
was
faster
than
a
hash
table
for
this
data
the
cost
of
computing
a
hash
was
more
than
the
left
right
comparisons
this
comment
teaches
the
reader
something
and
stops
any
would
be
optimizer
from
wasting
their
time
here
s
another
example
this
heuristic
might
miss
a
few
words
that
s
ok
solving
this
is
hard
without
this
comment
the
reader
might
think
there
s
a
bug
and
might
waste
time
trying
to
come
up
with
test
cases
that
make
it
fail
or
go
off
and
try
to
fix
the
bug
a
comment
can
also
explain
why
the
code
isn
t
in
great
shape
this
class
is
getting
messy
maybe
we
should
create
a
resourcenode
subclass
to
help
organize
things
this
comment
acknowledges
that
the
code
is
messy
but
also
encourages
the
next
person
to
fix
it
with
specifics
on
how
to
get
started
without
the
comment
many
readers
would
be
intimidated
by
the
messy
code
and
afraid
to
touch
it
comment
the
flaws
in
your
code
code
is
constantly
evolving
and
is
bound
to
have
flaws
along
the
way
don
t
be
embarrassed
to
document
those
flaws
for
example
noting
when
improvements
should
be
made
todo
use
a
faster
algorithm
or
when
code
is
incomplete
todo
dustin
handle
other
image
formats
besides
jpeg
there
are
a
number
of
markers
that
have
become
popular
among
programmers
marker
typical
meaning
todo
stuff
i
haven
t
gotten
around
to
yet
fixme
known
broken
code
here
hack
admittedly
inelegant
solution
to
a
problem
xxx
danger
major
problem
here
chapter
five
your
team
might
have
specific
conventions
for
when
if
to
use
these
markers
for
example
todo
might
be
reserved
for
show
stopping
issues
if
so
then
for
more
minor
flaws
you
could
use
something
like
todo
lower
case
or
maybe
later
instead
the
important
thing
is
that
you
should
always
feel
free
to
comment
on
your
thoughts
about
how
the
code
should
change
in
the
future
comments
like
these
give
readers
valuable
insight
into
the
quality
and
state
of
the
code
and
might
even
give
them
some
direction
on
how
to
improve
it
comment
on
your
constants
when
defining
a
constant
there
is
often
a
story
for
what
that
constant
does
or
why
it
has
that
specific
value
for
example
you
might
see
this
constant
in
your
code
num
threads
it
may
not
seem
like
this
line
needs
a
comment
but
it
s
likely
that
the
programmer
who
chose
it
knows
more
about
it
num
threads
as
long
as
it
s
num
processors
that
s
good
enough
now
the
person
reading
the
code
has
some
guidance
on
how
to
adjust
that
value
e
g
setting
it
to
is
probably
too
low
and
setting
it
to
is
overkill
or
sometimes
the
exact
value
of
a
constant
isn
t
important
at
all
a
comment
to
this
effect
is
still
useful
impose
a
reasonable
limit
no
human
can
read
that
much
anyway
const
int
max
rss
subscriptions
sometimes
it
s
a
value
that
s
been
highly
tuned
and
probably
shouldn
t
be
adjusted
much
image
quality
users
thought
gave
the
best
size
quality
tradeoff
in
all
these
examples
you
might
not
have
thought
to
add
comments
but
they
re
quite
helpful
there
are
some
constants
that
don
t
need
a
comment
because
their
name
is
clear
enough
e
g
seconds
per
day
but
in
our
experience
most
constants
could
be
improved
by
adding
a
comment
it
s
just
a
matter
of
jotting
down
what
you
were
thinking
about
when
you
decided
on
that
constant
s
value
put
yourself
in
the
reader
s
shoes
a
general
technique
we
use
in
this
book
is
to
imagine
what
your
code
looks
like
to
an
outsider
someone
who
isn
t
as
intimately
familiar
with
your
project
as
you
are
this
technique
is
especially
useful
to
help
you
recognize
what
needs
commenting
knowing
what
to
comment
anticipating
likely
questions
when
someone
else
reads
your
code
there
are
parts
likely
to
make
them
think
huh
what
s
this
all
about
your
job
is
to
comment
those
parts
for
example
take
a
look
at
the
definition
of
clear
struct
recorder
vector
float
data
void
clear
vector
float
swap
data
huh
why
not
just
data
clear
when
most
c
programmers
see
this
code
they
think
why
didn
t
he
just
do
data
clear
instead
of
swapping
with
an
empty
vector
well
it
turns
out
that
this
is
the
only
way
to
force
a
vector
to
truly
relinquish
its
memory
to
the
memory
allocator
it
s
a
c
detail
that
isn
t
well
known
the
bottom
line
is
that
it
should
be
commented
force
vector
to
relinquish
its
memory
look
up
stl
swap
trick
vector
float
swap
data
chapter
five
advertising
likely
pitfalls
when
documenting
a
function
or
class
a
good
question
to
ask
yourself
is
what
is
surprising
about
this
code
how
might
it
be
misused
basically
you
want
to
think
ahead
and
anticipate
the
problems
that
people
might
run
into
when
using
your
code
for
example
suppose
you
wrote
a
function
that
sends
an
email
to
a
given
user
void
sendemail
string
to
string
subject
string
body
the
implementation
of
this
function
involves
connecting
to
an
external
email
service
which
might
take
up
to
a
whole
second
or
possibly
longer
someone
who
is
writing
a
web
application
might
not
realize
this
and
mistakenly
call
this
function
while
handling
an
http
request
doing
this
would
cause
their
web
application
to
hang
if
the
email
service
is
down
knowing
what
to
comment
to
prevent
this
likely
mishap
you
should
comment
on
this
implementation
detail
calls
an
external
service
to
deliver
email
times
out
after
minute
void
sendemail
string
to
string
subject
string
body
here
is
another
example
suppose
you
have
a
fixbrokenhtml
function
that
attempts
to
rewrite
broken
html
by
inserting
missing
closing
tags
and
the
like
def
fixbrokenhtml
html
the
function
works
great
except
for
the
caveat
that
its
running
time
blows
up
when
there
are
deeply
nested
and
unmatched
tags
for
nasty
html
inputs
this
function
could
take
minutes
to
execute
rather
than
let
the
user
discover
this
later
on
his
own
it
s
better
to
announce
this
upfront
runtime
is
o
number
tags
average
tag
depth
so
watch
out
for
badly
nested
inputs
def
fixbrokenhtml
html
big
picture
comments
one
of
the
hardest
things
for
a
new
team
member
to
understand
is
the
big
picture
how
classes
interact
how
data
flows
through
the
whole
system
and
where
the
entry
points
are
the
person
who
designed
the
system
often
forgets
to
comment
about
this
stuff
because
he
s
so
intimately
involved
with
it
consider
this
thought
experiment
someone
new
just
joined
your
team
she
s
sitting
next
to
you
and
you
need
to
get
her
familiar
with
the
codebase
chapter
five
as
you
re
giving
her
a
tour
of
the
codebase
you
might
point
out
certain
files
or
classes
and
say
things
like
this
is
the
glue
code
between
our
business
logic
and
the
database
none
of
the
application
code
should
use
this
directly
this
class
looks
complicated
but
it
s
really
just
a
smart
cache
it
doesn
t
know
anything
about
the
rest
of
the
system
after
a
minute
of
casual
conversation
your
new
team
member
will
know
much
more
than
she
would
from
reading
the
source
by
herself
this
is
exactly
the
type
of
information
that
should
be
included
as
high
level
comments
here
s
a
simple
example
of
a
file
level
comment
this
file
contains
helper
functions
that
provide
a
more
convenient
interface
to
our
file
system
it
handles
file
permissions
and
other
nitty
gritty
details
don
t
get
overwhelmed
by
the
thought
that
you
have
to
write
extensive
formal
documentation
a
few
well
chosen
sentences
are
better
than
nothing
at
all
summary
comments
even
deep
inside
a
function
it
s
a
good
idea
to
comment
on
the
bigger
picture
here
s
an
example
of
a
comment
that
neatly
summarizes
the
low
level
code
below
it
find
all
the
items
that
customers
purchased
for
themselves
for
customer
id
in
all
customers
for
sale
in
all
sales
customer
id
sales
if
sale
recipient
customer
id
without
this
comment
reading
each
line
of
code
is
a
bit
of
a
mystery
i
see
we
re
iterating
through
all
customers
but
what
for
it
s
especially
helpful
to
have
these
summary
comments
in
longer
functions
where
there
are
a
few
large
chunks
inside
def
generateuserreport
acquire
a
lock
for
this
user
read
user
s
info
from
the
database
write
info
to
a
file
release
the
lock
for
this
user
knowing
what
to
comment
these
comments
also
act
as
a
bulleted
summary
of
what
the
function
does
so
the
reader
can
get
the
gist
of
what
the
function
does
before
diving
into
details
if
these
chunks
are
easily
separable
you
might
just
make
them
functions
of
their
own
as
we
mentioned
before
good
code
is
better
than
bad
code
with
good
comments
should
you
comment
the
what
the
why
or
the
how
you
may
have
heard
advice
like
comment
the
why
not
the
what
or
the
how
although
catchy
we
feel
these
statements
are
too
simplistic
and
mean
different
things
to
different
people
our
advice
is
to
do
whatever
helps
the
reader
understand
the
code
more
easily
this
may
involve
commenting
the
what
the
how
or
the
why
or
all
three
final
thoughts
getting
over
writer
s
block
a
lot
of
coders
don
t
like
to
write
comments
because
it
feels
like
a
lot
of
work
to
write
a
good
one
when
writers
have
this
sort
of
writer
s
block
the
best
solution
is
to
just
start
writing
so
the
next
time
you
re
hesitating
to
write
a
comment
just
go
ahead
and
comment
what
you
re
thinking
however
half
baked
it
may
be
for
example
suppose
you
re
working
on
a
function
and
think
to
yourself
oh
crap
this
stuff
will
get
tricky
if
there
are
ever
duplicates
in
this
list
just
write
that
down
oh
crap
this
stuff
will
get
tricky
if
there
are
ever
duplicates
in
this
list
see
was
that
so
hard
it
s
actually
not
that
bad
of
a
comment
certainly
better
than
nothing
the
language
is
a
little
vague
though
to
fix
it
we
can
just
go
through
each
phrase
and
replace
it
with
something
more
specific
by
oh
crap
you
really
mean
careful
this
is
something
to
watch
out
for
by
this
stuff
you
mean
the
code
that
s
handling
this
input
by
will
get
tricky
you
mean
will
be
hard
to
implement
the
new
comment
might
be
careful
this
code
doesn
t
handle
duplicates
in
the
list
because
that
s
hard
to
do
notice
that
we
ve
broken
down
the
task
of
writing
a
comment
into
these
simpler
steps
write
down
whatever
comment
is
on
your
mind
read
the
comment
and
see
what
if
anything
needs
to
be
improved
make
improvements
chapter
five
as
you
comment
more
often
you
ll
find
that
the
quality
of
comments
from
step
gets
better
and
better
and
eventually
might
not
need
fixing
at
all
and
by
commenting
early
and
often
you
avoid
the
unpleasant
situation
of
needing
to
write
a
bunch
of
comments
at
the
end
summary
the
purpose
of
a
comment
is
to
help
the
reader
know
what
the
writer
knew
when
writing
the
code
this
whole
chapter
is
about
realizing
all
the
not
so
obvious
nuggets
of
information
you
have
about
the
code
and
writing
those
down
what
not
to
comment
facts
that
can
be
quickly
derived
from
the
code
itself
crutch
comments
that
make
up
for
bad
code
such
as
a
bad
function
name
fix
the
code
instead
thoughts
you
should
be
recording
include
insights
about
why
code
is
one
way
and
not
another
director
commentary
flaws
in
your
code
by
using
markers
like
todo
or
xxx
the
story
for
how
a
constant
got
its
value
put
yourself
in
the
reader
s
shoes
anticipate
which
parts
of
your
code
will
make
readers
say
huh
and
comment
those
document
any
surprising
behavior
an
average
reader
wouldn
t
expect
use
big
picture
comments
at
the
file
class
level
to
explain
how
all
the
pieces
fit
together
summarize
blocks
of
code
with
comments
so
that
the
reader
doesn
t
get
lost
in
the
details
knowing
what
to
comment
chapter
six
making
comments
precise
and
compact
the
previous
chapter
was
about
realizing
what
you
should
be
commenting
this
chapter
is
about
how
to
write
comments
that
are
precise
and
compact
if
you
re
going
to
write
a
comment
at
all
it
might
as
well
be
precise
as
specific
and
detailed
as
possible
on
the
other
hand
comments
take
up
extra
space
on
the
screen
and
take
extra
time
to
read
so
comments
should
also
be
compact
key
idea
comments
should
have
a
high
information
to
space
ratio
the
rest
of
the
chapter
shows
examples
of
how
to
do
this
keep
comments
compact
here
s
an
example
of
a
comment
for
a
c
type
definition
the
int
is
the
categorytype
the
first
float
in
the
inner
pair
is
the
score
the
second
is
the
weight
typedef
hash
map
int
pair
float
float
scoremap
but
why
use
three
lines
to
explain
it
when
you
can
illustrate
it
in
just
one
line
categorytype
score
weight
typedef
hash
map
int
pair
float
float
scoremap
some
comments
need
three
lines
of
space
but
this
is
not
one
of
them
avoid
ambiguous
pronouns
as
the
classic
who
s
on
first
skit
illustrated
pronouns
can
make
things
very
confusing
it
takes
extra
work
for
the
reader
to
resolve
a
pronoun
and
in
some
cases
it
s
unclear
what
it
or
this
is
referring
to
here
s
an
example
insert
the
data
into
the
cache
but
check
if
it
s
too
big
first
in
this
comment
it
might
refer
to
the
data
or
the
cache
you
could
probably
figure
that
out
by
reading
the
rest
of
the
code
but
if
you
have
to
do
that
what
s
the
point
of
the
comment
the
safest
thing
is
to
fill
in
pronouns
if
there
s
any
chance
of
confusion
in
the
previous
example
let
s
assume
it
was
the
data
insert
the
data
into
the
cache
but
check
if
the
data
is
too
big
first
this
is
the
simplest
change
to
make
you
could
also
have
restructured
the
sentence
to
make
it
perfectly
clear
if
the
data
is
small
enough
insert
it
into
the
cache
chapter
six
polish
sloppy
sentences
in
many
cases
making
a
comment
more
precise
goes
hand
in
hand
with
making
it
more
compact
here
is
an
example
from
a
web
crawler
depending
on
whether
we
ve
already
crawled
this
url
before
give
it
a
different
priority
this
sentence
might
seem
okay
but
compare
it
to
this
version
give
higher
priority
to
urls
we
ve
never
crawled
before
this
sentence
is
simpler
smaller
and
more
direct
it
also
explains
that
higher
priority
is
given
to
uncrawled
urls
the
previous
comment
didn
t
contain
that
information
describe
function
behavior
precisely
imagine
you
just
wrote
a
function
that
counts
the
number
of
lines
in
a
file
return
the
number
of
lines
in
this
file
int
countlines
string
filename
this
comment
isn
t
very
precise
there
are
a
lot
of
ways
to
define
a
line
here
are
some
corner
cases
to
think
about
an
empty
file
or
line
hello
or
line
hello
n
or
lines
hello
n
world
or
lines
hello
n
r
cruel
n
world
r
or
lines
the
simplest
implementation
is
to
count
the
number
of
newline
n
characters
this
is
the
way
the
unix
command
wc
works
here
s
a
better
comment
to
match
this
implementation
count
how
many
newline
bytes
n
are
in
the
file
int
countlines
string
filename
this
comment
isn
t
much
longer
than
the
first
version
but
contains
much
more
information
it
tells
the
reader
that
the
function
might
return
if
there
are
no
newlines
it
also
tells
the
reader
that
carriage
returns
r
are
ignored
use
input
output
examples
that
illustrate
corner
cases
when
it
comes
to
comments
a
carefully
chosen
input
output
example
can
be
worth
a
thousand
words
making
comments
precise
and
compact
for
example
here
s
a
common
function
that
removes
parts
of
a
string
remove
the
suffix
prefix
of
chars
from
the
input
src
string
strip
string
src
string
chars
this
comment
isn
t
very
precise
because
it
can
t
answer
questions
such
as
is
chars
a
whole
substring
that
is
to
be
removed
or
effectively
just
an
unordered
set
of
letters
what
if
there
are
multiples
of
chars
on
the
end
of
src
instead
a
well
chosen
example
can
answer
these
questions
example
strip
abba
a
ba
ab
returns
a
string
strip
string
src
string
chars
the
example
shows
off
the
full
functionality
of
strip
note
that
a
simpler
example
wouldn
t
be
as
useful
if
it
doesn
t
answer
those
questions
example
strip
ab
a
returns
b
here
s
another
example
of
a
function
that
could
use
an
illustration
rearrange
v
so
that
elements
pivot
come
before
those
pivot
then
return
the
largest
i
for
which
v
i
pivot
or
if
none
are
pivot
int
partition
vector
int
v
int
pivot
this
comment
is
actually
very
precise
but
a
little
bit
hard
to
visualize
here
s
an
example
you
could
include
to
illustrate
things
further
example
partition
might
result
in
and
return
int
partition
vector
int
v
int
pivot
there
are
a
number
of
points
to
mention
about
the
specific
example
input
output
we
chose
the
pivot
is
equal
to
elements
in
the
vector
to
illustrate
that
edge
case
we
put
duplicates
in
the
vector
to
illustrate
that
this
is
an
acceptable
input
the
resulting
vector
is
not
sorted
if
it
were
the
reader
might
get
the
wrong
idea
because
the
return
value
was
we
made
sure
wasn
t
also
a
value
in
the
vector
that
would
be
confusing
state
the
intent
of
your
code
as
we
mentioned
in
the
previous
chapter
commenting
is
often
about
telling
the
reader
what
you
were
thinking
about
when
you
wrote
the
code
unfortunately
many
comments
end
up
just
describing
what
the
code
does
in
literal
terms
without
adding
much
new
information
chapter
six
here
s
an
example
of
such
a
comment
void
displayproducts
list
product
products
products
sort
compareproductbyprice
iterate
through
the
list
in
reverse
order
for
list
product
reverse
iterator
it
products
rbegin
it
products
rend
it
displayprice
it
price
all
this
comment
does
is
just
describe
the
line
below
it
instead
consider
this
better
comment
display
each
price
from
highest
to
lowest
for
list
product
reverse
iterator
it
products
rbegin
this
comment
explains
what
the
program
is
doing
at
a
higher
level
this
is
much
more
in
tune
with
what
the
programmer
was
thinking
when
she
wrote
the
code
interestingly
there
is
a
bug
in
this
program
the
compareproductbyprice
function
not
shown
already
sorts
higher
priced
items
first
the
code
is
doing
the
opposite
of
what
the
author
intended
this
is
a
good
reason
why
the
second
comment
is
better
despite
the
bug
the
first
comment
is
technically
correct
the
loop
does
iterate
in
reverse
order
but
with
the
second
comment
a
reader
is
more
likely
to
notice
that
the
intent
of
the
writer
to
show
higher
priced
items
first
contradicts
what
the
code
actually
does
in
effect
the
comment
acts
as
a
redundancy
check
ultimately
the
best
redundancy
check
is
a
unit
test
see
chapter
testing
and
readability
but
it
s
still
worthwhile
having
comments
like
these
explaining
the
intent
of
your
program
named
function
parameter
comments
suppose
you
saw
a
function
call
like
this
one
connect
false
this
function
call
is
a
bit
mysterious
because
of
those
integer
and
boolean
literals
being
passed
in
in
languages
like
python
you
can
assign
the
arguments
by
name
def
connect
timeout
use
encryption
call
the
function
using
named
parameters
connect
timeout
use
encryption
false
making
comments
precise
and
compact
in
languages
like
c
and
java
you
can
t
do
this
however
you
can
use
an
inline
comment
to
the
same
effect
void
connect
int
timeout
bool
use
encryption
call
the
function
with
commented
parameters
connect
timeout
ms
use
encryption
false
notice
that
we
named
the
first
parameter
timeout
ms
instead
of
timeout
ideally
the
function
s
real
argument
would
have
been
timeout
ms
but
if
for
some
reason
we
can
t
make
this
change
this
is
a
handy
way
to
improve
the
name
when
it
comes
to
boolean
arguments
it
s
especially
important
to
put
name
in
front
of
the
value
putting
the
comment
behind
the
value
is
very
confusing
don
t
do
this
connect
false
use
encryption
don
t
do
this
either
connect
false
use
encryption
in
these
examples
it
s
unclear
whether
false
means
use
encryption
or
don
t
use
encryption
most
function
calls
don
t
need
comments
like
these
but
it
s
a
handy
and
compact
way
to
explain
mysterious
looking
arguments
use
information
dense
words
once
you
ve
been
programming
for
a
number
of
years
you
notice
that
the
same
general
problems
and
solutions
come
up
repeatedly
often
there
are
specific
words
or
phrases
that
have
been
developed
to
describe
these
patterns
idioms
using
these
words
can
make
your
comments
much
more
compact
for
example
suppose
your
comment
were
this
class
contains
a
number
of
members
that
store
the
same
information
as
in
the
database
but
are
stored
here
for
speed
when
this
class
is
read
from
later
those
members
are
checked
first
to
see
if
they
exist
and
if
so
are
returned
otherwise
the
database
is
read
from
and
that
data
stored
in
those
fields
for
next
time
instead
you
could
just
say
this
class
acts
as
a
caching
layer
to
the
database
as
another
example
a
comment
such
as
remove
excess
whitespace
from
the
street
address
and
do
lots
of
other
cleanup
like
turn
avenue
into
ave
this
way
if
there
are
two
different
street
addresses
that
are
typed
in
slightly
differently
they
will
have
the
same
cleaned
up
version
and
we
can
detect
that
these
are
equal
could
instead
be
chapter
six
canonicalize
the
street
address
remove
extra
spaces
avenue
ave
etc
there
are
lots
of
words
and
phrases
that
pack
a
lot
of
meaning
such
as
heuristic
bruteforce
naive
solution
and
the
like
if
you
have
a
comment
that
feels
a
bit
long
winded
see
if
it
can
be
described
as
a
typical
programming
situation
summary
this
chapter
is
about
writing
comments
that
pack
as
much
information
into
as
small
a
space
as
possible
here
are
the
specific
tips
avoid
pronouns
like
it
and
this
when
they
can
refer
to
multiple
things
describe
a
function
s
behavior
with
as
much
precision
as
is
practical
illustrate
your
comments
with
carefully
chosen
input
output
examples
state
the
high
level
intent
of
your
code
rather
than
the
obvious
details
use
inline
comments
e
g
function
arg
to
explain
mysterious
function
arguments
keep
your
comments
brief
by
using
words
that
pack
a
lot
of
meaning
making
comments
precise
and
compact
part
ii
simplifying
loops
and
logic
in
part
i
we
covered
surface
level
improvements
simple
ways
to
improve
the
readability
of
your
code
one
line
at
a
time
that
can
be
applied
without
much
risk
or
effort
in
this
next
part
we
go
deeper
and
discuss
the
loops
and
logic
of
your
program
the
control
flow
logical
expressions
and
variables
that
make
your
code
work
as
always
our
goal
is
to
make
these
parts
of
your
code
easy
to
understand
we
do
this
by
trying
to
minimize
the
mental
baggage
of
your
code
every
time
you
see
a
complicated
loop
a
giant
expression
or
a
large
number
of
variables
this
adds
to
the
mental
baggage
in
your
head
it
requires
you
to
think
harder
and
remember
more
this
is
exactly
the
opposite
of
easy
to
understand
when
code
has
a
lot
of
mental
baggage
bugs
are
more
likely
to
go
unnoticed
the
code
becomes
harder
to
change
and
it
s
just
less
fun
to
work
with
chapter
seven
making
control
flow
easy
to
read
if
code
had
no
conditionals
loops
or
any
other
control
flow
statements
it
would
be
very
easy
to
read
these
jumps
and
branches
are
the
hard
stuff
where
code
can
get
confusing
quickly
this
chapter
is
about
making
the
control
flow
in
your
code
easy
to
read
key
idea
make
all
your
conditionals
loops
and
other
changes
to
control
flow
as
natural
as
possible
written
in
a
way
that
doesn
t
make
the
reader
stop
and
reread
your
code
the
order
of
arguments
in
conditionals
which
of
these
two
pieces
of
code
is
more
readable
if
length
or
if
length
to
most
programmers
the
first
is
much
more
readable
but
what
about
the
next
two
while
bytes
received
bytes
expected
or
while
bytes
expected
bytes
received
again
the
first
version
is
more
readable
but
why
what
s
the
general
rule
how
do
you
decide
whether
it
s
better
to
write
a
b
or
b
a
here
s
a
guideline
we
ve
found
useful
left
hand
side
right
hand
side
the
expression
being
interrogated
whose
value
is
more
in
the
expression
being
compared
against
whose
value
is
flux
more
constant
this
guideline
matches
english
usage
it
s
pretty
natural
to
say
if
you
make
at
least
k
year
or
if
you
are
at
least
years
old
it
s
unnatural
to
say
if
years
is
less
than
or
equal
to
your
age
this
explains
why
while
bytes
received
bytes
expected
is
more
readable
bytes
received
is
the
value
that
we
re
checking
up
on
and
it
s
increasing
as
the
loop
executes
bytes
expected
is
the
more
stable
value
being
compared
against
chapter
seven
yoda
notation
still
useful
in
some
languages
including
c
and
c
but
not
java
it
s
legal
to
put
an
assignment
inside
an
if
condition
if
obj
null
most
likely
this
is
a
bug
and
the
programmer
actually
meant
if
obj
null
to
prevent
bugs
like
this
many
programmers
switch
the
order
of
arguments
if
null
obj
this
way
if
is
accidentally
written
as
the
expression
if
null
obj
won
t
even
compile
unfortunately
switching
the
order
makes
the
code
a
bit
unnatural
to
read
as
yoda
would
say
not
if
anything
to
say
about
it
i
have
thankfully
modern
compilers
warn
against
code
like
if
obj
null
so
yoda
notation
is
becoming
a
thing
of
the
past
the
order
of
if
else
blocks
making
control
flow
easy
to
read
when
writing
an
if
else
statement
you
usually
have
the
freedom
to
swap
the
order
of
the
blocks
for
instance
you
can
either
write
it
like
if
a
b
case
one
else
case
two
or
as
if
a
b
case
two
else
case
one
you
may
not
have
given
much
thought
about
this
before
but
in
some
cases
there
are
good
reasons
to
prefer
one
order
over
the
other
prefer
dealing
with
the
positive
case
first
instead
of
the
negative
e
g
if
debug
instead
of
if
debug
prefer
dealing
with
the
simpler
case
first
to
get
it
out
of
the
way
this
approach
might
also
allow
both
the
if
and
the
else
to
be
visible
on
the
screen
at
the
same
time
which
is
nice
prefer
dealing
with
the
more
interesting
or
conspicuous
case
first
sometimes
these
preferences
conflict
and
you
have
to
make
a
judgment
call
but
in
many
cases
there
is
a
clear
winner
for
example
suppose
you
have
a
web
server
that
s
building
a
response
based
on
whether
the
url
contains
the
query
parameter
expand
all
if
url
hasqueryparameter
expand
all
response
render
items
else
for
int
i
i
items
size
i
items
i
expand
when
the
reader
glances
at
the
first
line
her
brain
immediately
thinks
about
the
expand
all
case
it
s
like
when
someone
says
don
t
think
of
a
pink
elephant
you
can
t
help
but
think
about
it
the
don
t
is
drowned
out
by
the
more
unusual
pink
elephant
here
expand
all
is
our
pink
elephant
because
it
s
the
more
interesting
case
and
it
s
the
positive
case
too
let
s
deal
with
it
first
if
url
hasqueryparameter
expand
all
for
int
i
i
items
size
i
items
i
expand
chapter
seven
else
response
render
items
on
the
other
hand
here
s
a
situation
where
the
negative
case
is
the
simpler
and
more
interesting
dangerous
one
so
we
deal
with
it
first
if
not
file
log
the
error
else
again
depending
on
the
details
this
may
be
a
judgment
call
to
summarize
our
advice
is
simply
to
pay
attention
to
these
factors
and
watch
out
for
cases
where
your
if
else
is
in
an
awkward
order
the
conditional
expression
a
k
a
ternary
operator
in
c
like
languages
you
can
write
a
conditional
expression
as
cond
a
b
which
is
essentially
a
compact
way
to
write
if
cond
a
else
b
its
effect
on
readability
is
controversial
proponents
think
it
s
a
nice
way
to
write
something
in
one
line
that
would
otherwise
require
multiple
lines
opponents
argue
that
it
can
be
confusing
to
read
and
difficult
to
step
through
in
a
debugger
here
s
a
case
where
the
ternary
operator
is
readable
and
compact
time
str
hour
pm
am
avoiding
the
ternary
operator
you
might
write
if
hour
time
str
pm
else
time
str
am
which
is
a
bit
drawn
out
and
redundant
in
this
case
a
conditional
expression
seems
reasonable
however
these
expressions
can
quickly
become
difficult
to
read
return
exponent
mantissa
exponent
mantissa
exponent
here
the
ternary
operator
is
no
longer
just
choosing
between
two
simple
values
the
motivation
for
writing
code
like
this
is
usually
to
squeeze
everything
on
one
line
key
idea
instead
of
minimizing
the
number
of
lines
a
better
metric
is
to
minimize
the
time
needed
for
someone
to
understand
it
making
control
flow
easy
to
read
spelling
out
the
logic
with
an
if
else
statement
makes
the
code
more
natural
if
exponent
return
mantissa
exponent
else
return
mantissa
exponent
advice
by
default
use
an
if
else
the
ternary
should
be
used
only
for
the
simplest
cases
avoid
do
while
loops
many
respected
programming
languages
as
well
as
perl
have
a
do
expression
while
condition
loop
the
expression
is
executed
at
least
once
here
s
an
example
search
through
the
list
starting
at
node
for
the
given
name
don
t
consider
more
than
max
length
nodes
public
boolean
listhasnode
node
node
string
name
int
max
length
do
if
node
name
equals
name
return
true
node
node
next
while
node
null
max
length
return
false
chapter
seven
what
s
weird
about
a
do
while
loop
is
that
a
block
of
code
may
or
may
not
be
reexecuted
based
on
a
condition
underneath
it
typically
logical
conditions
are
above
the
code
they
guard
this
is
the
way
it
works
with
if
while
and
for
statements
because
you
typically
read
code
from
top
to
bottom
this
makes
do
while
a
bit
unnatural
many
readers
end
up
reading
the
code
twice
while
loops
are
easier
to
read
because
you
know
the
condition
for
all
iterations
before
you
read
the
block
of
code
inside
but
it
would
be
silly
to
duplicate
code
just
to
remove
a
do
while
imitating
a
do
while
don
t
do
this
body
while
condition
body
again
fortunately
we
ve
found
that
in
practice
most
do
while
loops
could
have
been
written
as
while
loops
to
begin
with
public
boolean
listhasnode
node
node
string
name
int
max
length
while
node
null
max
length
if
node
name
equals
name
return
true
node
node
next
return
false
this
version
also
has
the
benefit
that
it
still
works
if
max
length
is
or
if
node
is
null
another
reason
to
avoid
do
while
is
that
the
continue
statement
can
be
confusing
inside
it
for
instance
what
does
this
code
do
do
continue
while
false
does
it
loop
forever
or
just
once
most
programmers
have
to
stop
and
think
about
it
it
should
loop
just
once
overall
bjarne
stroustrup
the
creator
of
c
says
it
best
in
the
c
programming
language
in
my
experience
the
do
statement
is
a
source
of
errors
and
confusion
i
prefer
the
condition
up
front
where
i
can
see
it
consequently
i
tend
to
avoid
do
statements
returning
early
from
a
function
some
coders
believe
that
functions
should
never
have
multiple
return
statements
this
is
nonsense
returning
early
from
a
function
is
perfectly
fine
and
often
desirable
for
example
public
boolean
contains
string
str
string
substr
if
str
null
substr
null
return
false
if
substr
equals
return
true
making
control
flow
easy
to
read
implementing
this
function
without
these
guard
clauses
would
be
very
unnatural
one
of
the
motivations
for
wanting
a
single
exit
point
is
so
that
all
the
cleanup
code
at
the
bottom
of
the
function
is
guaranteed
to
be
called
but
modern
languages
offer
more
sophisticated
ways
to
achieve
this
guarantee
language
structured
idiom
for
cleanup
code
c
destructors
java
python
try
finally
python
with
c
using
in
pure
c
there
is
no
mechanism
to
trigger
specific
code
when
a
function
exits
so
if
there
s
a
large
function
with
a
lot
of
cleanup
code
returning
early
may
be
difficult
to
do
correctly
in
this
case
other
options
include
refactoring
the
function
or
even
judicious
use
of
goto
cleanup
the
infamous
goto
in
languages
other
than
c
there
is
little
need
for
goto
because
there
are
so
many
better
ways
to
get
the
job
done
gotos
are
also
notorious
for
getting
out
of
hand
quickly
and
making
code
difficult
to
follow
but
you
can
still
see
goto
used
in
various
c
projects
most
notably
the
linux
kernel
before
you
dismiss
all
use
of
goto
as
blasphemy
it
s
useful
to
dissect
why
some
uses
of
goto
are
better
than
others
the
simplest
most
innocent
use
of
goto
is
with
a
single
exit
at
the
bottom
of
a
function
if
p
null
goto
exit
exit
fclose
file
fclose
file
return
if
this
were
the
only
form
of
goto
allowed
goto
wouldn
t
be
much
of
a
problem
the
problems
can
come
when
there
are
multiple
goto
targets
especially
when
their
paths
cross
in
particular
gotos
that
go
upward
can
make
for
real
spaghetti
code
and
they
can
surely
be
replaced
with
structured
loops
most
of
the
time
goto
should
be
avoided
chapter
seven
minimize
nesting
deeply
nested
code
is
hard
to
understand
each
level
of
nesting
pushes
an
extra
condition
onto
the
reader
s
mental
stack
when
the
reader
sees
a
closing
brace
it
can
be
hard
to
pop
the
stack
and
remember
what
condition
is
underneath
here
is
a
relatively
simple
example
of
this
see
if
you
notice
yourself
looking
back
up
to
doublecheck
which
block
conditions
you
re
in
if
user
result
success
if
permission
result
success
reply
writeerrors
error
reading
permissions
reply
done
return
reply
writeerrors
else
reply
writeerrors
user
result
reply
done
when
you
see
that
first
closing
brace
you
have
to
think
to
yourself
oh
permission
result
success
has
just
ended
so
now
permission
result
success
and
this
is
still
inside
the
block
where
user
result
success
overall
you
have
to
keep
the
values
of
user
result
and
permission
result
in
your
head
at
all
times
and
as
each
if
block
closes
you
have
to
toggle
the
corresponding
value
in
your
mind
this
particular
code
is
even
worse
because
it
keeps
alternating
between
the
success
and
nonsuccess
situations
how
nesting
accumulates
before
we
try
to
fix
the
previous
example
code
let
s
talk
about
how
it
ended
up
the
way
it
did
originally
the
code
was
simple
if
user
result
success
reply
writeerrors
else
reply
writeerrors
user
result
reply
done
this
code
is
perfectly
understandable
it
figures
out
what
error
string
to
write
and
then
it
s
done
with
the
reply
but
then
the
programmer
added
a
second
operation
if
user
result
success
if
permission
result
success
reply
writeerrors
error
reading
permissions
making
control
flow
easy
to
read
reply
done
return
reply
writeerrors
this
change
makes
sense
the
programmer
had
a
new
chunk
of
code
to
insert
and
she
found
the
easiest
place
to
insert
it
this
new
code
was
fresh
and
mentally
bolded
in
her
mind
and
the
diff
of
this
change
is
very
clean
it
looks
like
a
simple
change
but
when
someone
else
comes
across
the
code
later
all
that
context
is
gone
this
is
the
way
it
was
for
you
when
you
first
read
the
code
at
the
beginning
of
this
section
you
had
to
take
it
in
all
at
once
key
idea
look
at
your
code
from
a
fresh
perspective
when
you
re
making
changes
step
back
and
look
at
it
as
a
whole
removing
nesting
by
returning
early
okay
so
let
s
improve
the
code
nesting
like
this
can
be
removed
by
handling
the
failure
cases
as
soon
as
possible
and
returning
early
from
the
function
if
user
result
success
reply
writeerrors
user
result
reply
done
return
if
permission
result
success
reply
writeerrors
permission
result
reply
done
return
reply
writeerrors
reply
done
this
code
only
has
one
level
of
nesting
instead
of
two
but
more
importantly
the
reader
never
has
to
pop
anything
from
his
mental
stack
every
if
block
ends
in
a
return
removing
nesting
inside
loops
the
technique
of
returning
early
isn
t
always
applicable
for
example
here
s
a
case
of
code
nested
in
a
loop
for
int
i
i
results
size
i
if
results
i
null
non
null
count
chapter
seven
if
results
i
name
cout
considering
candidate
endl
inside
a
loop
the
analogous
technique
to
returning
early
is
to
continue
for
int
i
i
results
size
i
if
results
i
null
continue
non
null
count
if
results
i
name
continue
cout
considering
candidate
endl
in
the
same
way
that
an
if
return
acts
as
a
guard
clause
for
a
function
these
if
continue
statements
act
as
guard
clauses
for
the
loop
in
general
the
continue
statement
can
be
confusing
because
it
bounces
the
reader
around
like
a
goto
inside
the
loop
but
in
this
case
each
iteration
of
the
loop
is
independent
the
loop
is
a
for
each
so
the
reader
can
easily
see
that
continue
just
means
skip
over
this
item
can
you
follow
the
flow
of
execution
making
control
flow
easy
to
read
this
chapter
has
been
about
low
level
control
flow
how
to
make
loops
conditionals
and
other
jumps
easy
to
read
but
you
should
also
think
about
the
flow
of
your
program
at
a
high
level
ideally
it
would
be
easy
to
follow
the
entire
execution
path
of
your
program
you
d
start
at
main
and
mentally
step
through
the
code
as
one
function
calls
another
until
the
program
exits
in
practice
however
programming
languages
and
libraries
have
constructs
that
let
code
execute
behind
the
scenes
or
make
it
difficult
to
follow
here
are
some
examples
programming
construct
how
high
level
program
flow
gets
obscured
threading
it
s
unclear
what
code
is
executed
when
signal
interrupt
handlers
certain
code
might
be
executed
at
any
time
exceptions
execution
can
bubble
up
through
multiple
function
calls
function
pointers
anonymous
functions
it
s
hard
to
know
exactly
what
code
is
going
to
run
because
that
isn
t
known
at
compile
time
virtual
methods
object
virtualmethod
might
invoke
code
of
an
unknown
subclass
some
of
these
constructs
are
very
useful
and
they
can
even
make
your
code
more
readable
and
less
redundant
but
as
programmers
sometimes
we
get
carried
away
and
use
them
excessively
without
realizing
how
difficult
it
will
be
for
readers
to
understand
the
code
later
also
these
constructs
make
bugs
much
harder
to
track
down
the
key
is
to
not
let
too
large
a
percentage
of
your
code
use
these
constructs
if
you
abuse
these
features
it
can
make
tracing
through
your
code
like
a
game
of
three
card
monte
as
in
the
cartoon
summary
there
are
a
number
of
things
you
can
do
to
make
your
code
s
control
flow
easier
to
read
when
writing
a
comparison
while
bytes
expected
bytes
received
it
s
better
to
put
the
changing
value
on
the
left
and
the
more
stable
value
on
the
right
while
bytes
received
bytes
expected
you
can
also
reorder
the
blocks
of
an
if
else
statement
generally
try
to
handle
the
positive
easier
interesting
case
first
sometimes
these
criteria
conflict
but
when
they
don
t
it
s
a
good
rule
of
thumb
to
follow
certain
programming
constructs
like
the
ternary
operator
the
do
while
loop
and
goto
often
result
in
unreadable
code
it
s
usually
best
not
to
use
them
as
clearer
alternatives
almost
always
exist
chapter
seven
nested
code
blocks
require
more
concentration
to
follow
along
each
new
nesting
requires
more
context
to
be
pushed
onto
the
stack
of
the
reader
instead
opt
for
more
linear
code
to
avoid
deep
nesting
returning
early
can
remove
nesting
and
clean
up
code
in
general
guard
statements
handling
simple
cases
at
the
top
of
the
function
are
especially
useful
making
control
flow
easy
to
read
chapter
eight
breaking
down
giant
expressions
the
giant
squid
is
an
amazing
and
intelligent
animal
but
its
near
perfect
body
design
has
one
fatal
flaw
it
has
a
donut
shaped
brain
that
wraps
around
its
esophagus
so
if
it
swallows
too
much
food
at
once
it
gets
brain
damage
what
does
this
have
to
do
with
code
well
code
that
comes
in
chunks
that
are
too
big
can
have
the
same
kind
of
effect
recent
research
suggests
that
most
of
us
can
only
think
about
three
or
four
things
at
a
time
simply
put
the
larger
an
expression
of
code
is
the
harder
it
will
be
to
understand
key
idea
break
down
your
giant
expressions
into
more
digestible
pieces
in
this
chapter
we
ll
go
through
various
ways
you
can
manipulate
and
break
down
your
code
so
that
it
s
easier
to
swallow
explaining
variables
the
simplest
way
to
break
down
an
expression
is
to
introduce
an
extra
variable
that
captures
a
smaller
subexpression
this
extra
variable
is
sometimes
called
an
explaining
variable
because
it
helps
explain
what
the
subexpression
means
here
is
an
example
if
line
split
strip
root
here
is
the
same
code
now
with
an
explaining
variable
username
line
split
strip
if
username
root
summary
variables
even
if
an
expression
doesn
t
need
explaining
because
you
can
figure
out
what
it
means
it
can
still
be
useful
to
capture
that
expression
in
a
new
variable
we
call
this
a
summary
variable
if
its
purpose
is
simply
to
replace
a
larger
chunk
of
code
with
a
smaller
name
that
can
be
managed
and
thought
about
more
easily
for
example
consider
the
expressions
in
this
code
if
request
user
id
document
owner
id
user
can
edit
this
document
cowan
n
the
magical
number
in
short
term
memory
a
reconsideration
of
mental
storage
capacity
behavioral
and
brain
sciences
chapter
eight
if
request
user
id
document
owner
id
document
is
read
only
the
expression
request
user
id
document
owner
id
may
not
seem
that
big
but
it
has
five
variables
so
it
takes
a
little
extra
time
to
think
about
the
main
concept
in
this
code
is
does
the
user
own
the
document
that
concept
can
be
stated
more
clearly
by
adding
a
summary
variable
final
boolean
user
owns
document
request
user
id
document
owner
id
if
user
owns
document
user
can
edit
this
document
if
user
owns
document
document
is
read
only
it
may
not
seem
like
much
but
the
statement
if
user
owns
document
is
a
little
easier
to
think
about
also
having
user
owns
document
defined
at
the
top
tells
the
reader
upfront
that
this
is
a
concept
we
ll
be
referring
to
throughout
this
function
using
de
morgan
s
laws
if
you
ever
took
a
course
in
circuits
or
logic
you
might
remember
de
morgan
s
laws
they
are
two
ways
to
rewrite
a
boolean
expression
into
an
equivalent
one
not
a
or
b
or
c
not
a
and
b
and
c
not
a
and
not
b
and
not
c
not
a
or
not
b
or
not
c
if
you
have
trouble
remembering
these
laws
a
simple
summary
is
distribute
the
not
and
switch
and
or
or
going
the
other
way
you
factor
out
the
not
you
can
sometimes
use
these
laws
to
make
a
boolean
expression
more
readable
for
instance
if
your
code
is
if
file
exists
is
protected
error
sorry
could
not
read
file
it
can
be
rewritten
to
if
file
exists
is
protected
error
sorry
could
not
read
file
breaking
down
giant
expressions
abusing
short
circuit
logic
in
most
programming
languages
boolean
operators
perform
short
circuit
evaluation
for
example
the
statement
if
a
b
won
t
evaluate
b
if
a
is
true
this
behavior
is
very
handy
but
can
sometimes
be
abused
to
accomplish
complex
logic
here
is
an
example
of
a
statement
once
written
by
one
of
the
authors
assert
bucket
findbucket
key
bucket
isoccupied
in
english
what
this
code
is
saying
is
get
the
bucket
for
this
key
if
the
bucket
is
not
null
then
make
sure
it
isn
t
occupied
even
though
it
s
only
one
line
of
code
it
really
makes
most
programmers
stop
and
think
now
compare
it
to
this
code
bucket
findbucket
key
if
bucket
null
assert
bucket
isoccupied
it
does
exactly
the
same
thing
and
even
though
it
s
two
lines
of
code
it
s
much
easier
to
understand
so
why
was
the
code
written
as
a
single
giant
expression
in
the
first
place
at
the
time
it
felt
very
clever
there
s
a
certain
pleasure
in
paring
logic
down
to
a
concise
nugget
of
code
that
s
understandable
it
s
like
solving
a
miniature
puzzle
and
we
all
like
to
have
fun
at
work
the
problem
is
that
the
code
was
a
mental
speed
bump
for
anyone
reading
through
the
code
key
idea
beware
of
clever
nuggets
of
code
they
re
often
confusing
when
others
read
the
code
later
does
this
mean
you
should
avoid
making
use
of
short
circuit
behavior
no
there
are
plenty
of
cases
where
it
can
be
used
cleanly
for
instance
if
object
object
method
there
is
also
a
newer
idiom
worth
mentioning
in
languages
like
python
javascript
and
ruby
the
or
operator
returns
one
of
its
arguments
it
doesn
t
convert
to
a
boolean
so
code
like
x
a
b
c
can
be
used
to
pick
out
the
first
truthy
value
from
a
b
or
c
example
wrestling
with
complicated
logic
suppose
you
re
implementing
the
following
range
class
struct
range
int
begin
int
end
chapter
eight
for
example
overlaps
with
bool
overlapswith
range
other
the
following
figure
shows
some
example
ranges
note
that
end
is
noninclusive
so
a
b
and
c
don
t
overlap
with
each
other
but
d
overlaps
with
all
of
them
here
is
one
attempt
at
implementing
overlapswith
it
checks
if
either
endpoint
of
its
range
falls
inside
the
other
s
range
bool
range
overlapswith
range
other
check
if
begin
or
end
falls
inside
other
return
begin
other
begin
begin
other
end
end
other
begin
end
other
end
even
though
the
code
is
only
two
lines
long
there
s
a
lot
going
on
the
following
figure
shows
all
the
logic
involved
there
are
so
many
cases
and
conditions
to
think
about
that
it
s
easy
for
a
bug
to
slip
by
speaking
of
which
there
is
a
bug
the
previous
code
will
claim
that
the
range
overlaps
with
when
in
fact
it
doesn
t
breaking
down
giant
expressions
the
problem
is
that
you
have
to
be
careful
when
comparing
begin
end
values
using
or
just
here
s
a
fix
to
this
problem
return
begin
other
begin
begin
other
end
end
other
begin
end
other
end
now
it
s
correct
right
actually
there
s
another
bug
this
code
has
ignored
the
case
when
begin
end
completely
surround
other
here
s
a
fix
that
handles
this
case
too
return
begin
other
begin
begin
other
end
end
other
begin
end
other
end
begin
other
begin
end
other
end
yikes
this
code
has
become
way
too
complicated
you
can
t
expect
anyone
to
read
this
code
and
confidently
know
that
it
s
correct
so
what
do
we
do
how
can
we
break
down
this
giant
expression
finding
a
more
elegant
approach
this
is
one
of
those
times
when
you
should
stop
and
consider
a
different
approach
altogether
what
started
as
a
simple
problem
checking
whether
two
ranges
overlap
turned
into
a
surprisingly
convoluted
piece
of
logic
this
is
often
a
sign
that
there
must
be
an
easier
way
but
finding
a
more
elegant
solution
takes
creativity
how
do
you
go
about
it
one
technique
is
to
see
if
you
can
solve
the
problem
the
opposite
way
depending
on
the
situation
you
re
in
this
could
mean
iterating
through
arrays
in
reverse
or
filling
in
some
data
structure
backward
rather
than
forward
here
the
opposite
of
overlapswith
is
doesn
t
overlap
determining
if
two
ranges
don
t
overlap
turns
out
to
be
a
much
simpler
problem
because
there
are
only
two
possibilities
the
other
range
ends
before
this
one
begins
the
other
range
begins
after
this
one
ends
we
can
turn
this
into
code
quite
easily
bool
range
overlapswith
range
other
if
other
end
begin
return
false
if
other
begin
end
return
false
return
true
they
end
before
we
begin
they
begin
after
we
end
only
possibility
left
they
overlap
each
line
of
code
here
is
much
simpler
it
involves
only
a
single
comparison
that
leaves
the
reader
with
enough
brainpower
to
focus
on
whether
is
correct
chapter
eight
breaking
down
giant
statements
this
chapter
is
about
breaking
down
individual
expressions
but
the
same
techniques
apply
to
breaking
down
larger
statements
as
well
for
example
the
following
javascript
code
has
a
lot
to
take
in
at
once
var
update
highlight
function
message
num
if
vote
value
message
num
html
up
thumbs
up
message
num
addclass
highlighted
thumbs
down
message
num
removeclass
highlighted
else
if
vote
value
message
num
html
down
thumbs
up
message
num
removeclass
highlighted
thumbs
down
message
num
addclass
highlighted
else
thumbs
up
message
num
removeclass
highighted
thumbs
down
message
num
removeclass
highlighted
the
individual
expressions
in
this
code
aren
t
that
big
but
when
placed
all
together
it
forms
one
giant
statement
that
hits
you
all
at
once
fortunately
a
lot
of
the
expressions
are
the
same
which
means
we
can
extract
them
out
as
summary
variables
at
the
top
of
the
function
this
is
also
an
instance
of
the
dry
don
t
repeat
yourself
principle
var
update
highlight
function
message
num
var
thumbs
up
thumbs
up
message
num
var
thumbs
down
thumbs
down
message
num
var
vote
value
vote
value
message
num
html
var
hi
highlighted
if
vote
value
up
thumbs
up
addclass
hi
thumbs
down
removeclass
hi
else
if
vote
value
down
thumbs
up
removeclass
hi
thumbs
down
addclass
hi
else
thumbs
up
removeclass
hi
thumbs
down
removeclass
hi
the
creation
of
var
hi
highlighted
isn
t
strictly
needed
but
as
there
were
six
copies
of
it
there
were
compelling
benefits
it
helps
avoid
typing
mistakes
in
fact
did
you
notice
that
in
the
first
example
the
string
was
misspelled
as
highighted
in
the
fifth
case
it
shrinks
the
line
width
even
more
making
the
code
easier
to
scan
through
if
the
class
name
needed
to
change
there
s
just
one
place
to
change
it
breaking
down
giant
expressions
another
creative
way
to
simplify
expressions
here
s
another
example
with
a
lot
going
on
in
each
expression
this
time
in
c
void
addstats
const
stats
add
from
stats
add
to
add
to
set
total
memory
add
from
total
memory
add
to
total
memory
add
to
set
free
memory
add
from
free
memory
add
to
free
memory
add
to
set
swap
memory
add
from
swap
memory
add
to
swap
memory
add
to
set
status
string
add
from
status
string
add
to
status
string
add
to
set
num
processes
add
from
num
processes
add
to
num
processes
once
again
your
eyes
are
faced
with
code
that
s
long
and
similar
but
not
exactly
the
same
after
ten
seconds
of
careful
scrutiny
you
might
realize
that
each
line
is
doing
the
same
thing
just
to
a
different
field
each
time
add
to
set
xxx
add
from
xxx
add
to
xxx
in
c
we
can
define
a
macro
to
implement
this
void
addstats
const
stats
add
from
stats
add
to
define
add
field
field
add
to
set
field
add
from
field
add
to
field
add
field
total
memory
add
field
free
memory
add
field
swap
memory
add
field
status
string
add
field
num
processes
undef
add
field
now
that
we
ve
stripped
away
all
the
clutter
you
can
look
at
the
code
and
immediately
understand
the
essence
of
what
s
happening
it
s
very
clear
that
each
line
is
doing
the
same
thing
note
that
we
re
not
advocating
using
macros
very
often
in
fact
we
usually
avoid
them
because
they
can
make
code
confusing
and
introduce
subtle
bugs
but
sometimes
as
in
this
case
they
re
simple
and
can
provide
a
clear
benefit
to
readability
summary
giant
expressions
are
hard
to
think
about
this
chapter
showed
a
number
of
ways
to
break
them
down
so
the
reader
can
digest
them
piece
by
piece
chapter
eight
one
simple
technique
is
to
introduce
explaining
variables
that
capture
the
value
of
some
large
subexpression
this
approach
has
three
benefits
it
breaks
down
a
giant
expression
into
pieces
it
documents
the
code
by
describing
the
subexpression
with
a
succinct
name
it
helps
the
reader
identify
the
main
concepts
in
the
code
another
technique
is
to
manipulate
your
logic
using
de
morgan
s
laws
this
technique
can
sometimes
rewrite
a
boolean
expression
in
a
cleaner
way
e
g
if
a
b
turns
into
if
a
b
we
showed
an
example
where
a
complex
logical
condition
was
broken
down
into
tiny
statements
like
if
a
b
in
fact
all
of
the
improved
code
examples
in
this
chapter
had
if
statements
with
no
more
than
two
values
inside
them
this
setup
is
ideal
it
may
not
always
seem
possible
to
do
this
sometimes
it
requires
negating
the
problem
or
considering
the
opposite
of
your
goal
finally
even
though
this
chapter
is
about
breaking
down
individual
expressions
these
same
techniques
often
apply
to
larger
blocks
of
code
too
so
be
aggressive
in
breaking
down
complex
logic
wherever
you
see
it
breaking
down
giant
expressions
chapter
nine
variables
and
readability
in
this
chapter
you
ll
see
how
sloppy
use
of
variables
makes
a
program
harder
to
understand
specifically
there
are
three
problems
to
contend
with
the
more
variables
there
are
the
harder
it
is
to
keep
track
of
them
all
the
bigger
a
variable
s
scope
the
longer
you
have
to
keep
track
of
it
the
more
often
a
variable
changes
the
harder
it
is
to
keep
track
of
its
current
value
the
next
three
sections
discuss
how
to
deal
with
these
issues
eliminating
variables
in
chapter
breaking
down
giant
expressions
we
showed
how
introducing
explaining
or
summary
variables
can
make
code
more
readable
these
variables
were
helpful
because
they
broke
down
giant
expressions
and
acted
as
a
form
of
documentation
in
this
section
we
re
interested
in
eliminating
variables
that
don
t
improve
readability
when
a
variable
like
this
is
removed
the
new
code
is
more
concise
and
just
as
easy
to
understand
in
the
following
section
are
a
few
examples
of
how
these
unnecessary
variables
show
up
useless
temporary
variables
in
the
following
snippet
of
python
code
consider
the
now
variable
now
datetime
datetime
now
root
message
last
view
time
now
is
now
a
variable
worth
keeping
no
and
here
are
the
reasons
it
isn
t
breaking
down
a
complex
expression
it
doesn
t
add
clarification
the
expression
datetime
datetime
now
is
clear
enough
it
s
used
only
once
so
it
doesn
t
compress
any
redundant
code
without
now
the
code
is
just
as
easy
to
understand
root
message
last
view
time
datetime
datetime
now
variables
like
now
are
usually
leftovers
that
remain
after
code
has
been
edited
the
variable
now
might
have
been
used
in
multiple
places
originally
or
maybe
the
coder
anticipated
using
now
multiple
times
but
never
actually
needed
it
chapter
nine
eliminating
intermediate
results
here
s
an
example
of
a
javascript
function
that
removes
a
value
from
an
array
var
remove
one
function
array
value
to
remove
var
index
to
remove
null
for
var
i
i
array
length
i
if
array
i
value
to
remove
index
to
remove
i
break
if
index
to
remove
null
array
splice
index
to
remove
the
variable
index
to
remove
is
just
used
to
hold
an
intermediate
result
variables
like
this
can
sometimes
be
eliminated
by
handling
the
result
as
soon
as
you
get
it
var
remove
one
function
array
value
to
remove
for
var
i
i
array
length
i
if
array
i
value
to
remove
array
splice
i
return
by
allowing
the
code
to
return
early
we
got
rid
of
index
to
remove
altogether
and
simplified
the
code
quite
a
bit
in
general
it
s
a
good
strategy
to
complete
the
task
as
quickly
as
possible
variables
and
readability
eliminating
control
flow
variables
sometimes
you
ll
see
this
pattern
of
code
in
loops
boolean
done
false
while
condition
done
if
done
true
continue
the
variable
done
might
even
be
set
to
true
in
multiple
places
throughout
the
loop
code
like
this
is
often
trying
to
satisfy
some
unspoken
rule
that
you
shouldn
t
break
out
of
the
middle
of
a
loop
there
is
no
such
rule
variables
like
done
are
what
we
call
control
flow
variables
their
sole
purpose
is
to
steer
the
program
s
execution
they
don
t
contain
any
real
program
data
in
our
experience
control
flow
variables
can
often
be
eliminated
by
making
better
use
of
structured
programming
while
condition
if
break
this
case
was
pretty
easy
to
fix
but
what
if
there
are
multiple
nested
loops
for
which
a
simple
break
wouldn
t
suffice
in
more
complicated
cases
like
that
the
solution
often
involves
moving
code
into
a
new
function
either
the
code
inside
the
loop
or
the
entire
loop
itself
do
you
want
your
coworkers
to
feel
like
they
re
in
an
interview
all
the
time
microsoft
s
eric
brechner
has
talked
about
how
a
great
interview
question
should
involve
at
least
three
variables
it
s
probably
because
dealing
with
three
variables
at
the
same
time
forces
you
to
think
hard
this
makes
sense
for
an
interview
where
you
re
trying
to
push
a
candidate
to
the
limit
but
do
you
want
your
coworkers
to
feel
like
they
re
in
an
interview
while
they
re
reading
your
code
eric
brechner
s
i
m
wright
s
hard
code
microsoft
press
p
chapter
nine
shrink
the
scope
of
your
variables
we
ve
all
heard
the
advice
to
avoid
global
variables
this
is
good
advice
because
it
s
hard
to
keep
track
of
where
and
how
all
those
global
variables
are
being
used
and
by
polluting
the
namespace
putting
a
bunch
of
names
there
that
might
conflict
with
your
local
variables
code
might
accidentally
modify
a
global
variable
when
it
intended
to
use
a
local
variable
or
vice
versa
in
fact
it
s
a
good
idea
to
shrink
the
scope
of
all
your
variables
not
just
the
global
ones
key
idea
make
your
variable
visible
by
as
few
lines
of
code
as
possible
many
programming
languages
offer
multiple
scope
access
levels
including
module
class
function
and
block
scope
using
more
restricted
access
is
generally
better
because
it
means
the
variable
can
be
seen
by
fewer
lines
of
code
why
do
this
because
it
effectively
reduces
the
number
of
variables
the
reader
has
to
think
about
at
the
same
time
if
you
were
to
shrink
the
scope
of
all
your
variables
by
a
factor
of
two
then
on
average
there
would
be
half
as
many
variables
in
scope
at
any
one
time
for
example
suppose
you
have
a
very
large
class
with
a
member
variable
that
s
used
by
only
two
methods
in
the
following
way
class
largeclass
string
str
void
method
str
method
void
method
uses
str
lots
of
other
methods
that
don
t
use
str
in
some
sense
a
class
member
variable
is
like
a
mini
global
inside
the
realm
of
the
class
for
large
classes
especially
it
s
hard
to
keep
track
of
all
the
member
variables
and
which
methods
modify
each
one
the
fewer
mini
globals
the
better
for
this
case
it
may
make
sense
to
demote
str
to
be
a
local
variable
class
largeclass
void
method
string
str
method
str
variables
and
readability
void
method
string
str
uses
str
now
other
methods
can
t
see
str
another
way
to
restrict
access
to
class
members
is
to
make
as
many
methods
static
as
possible
static
methods
are
a
great
way
to
let
the
reader
know
these
lines
of
code
are
isolated
from
those
variables
or
another
approach
is
to
break
the
large
class
into
smaller
classes
this
approach
is
helpful
only
if
the
smaller
classes
are
in
fact
isolated
from
each
other
if
you
were
to
create
two
classes
that
access
each
other
s
members
you
haven
t
really
accomplished
anything
the
same
goes
for
breaking
up
large
files
into
smaller
files
or
large
functions
into
smaller
functions
a
big
motivation
for
doing
so
is
to
isolate
data
i
e
variables
but
different
languages
have
different
rules
for
what
exactly
constitutes
a
scope
we
d
like
to
point
out
just
a
few
of
the
more
interesting
rules
involving
the
scope
of
variables
if
statement
scope
in
c
suppose
you
have
the
following
c
code
paymentinfo
info
database
readpaymentinfo
if
info
cout
user
paid
info
amount
endl
many
more
lines
of
code
below
the
variable
info
will
remain
in
scope
for
the
rest
of
the
function
so
the
person
reading
this
code
might
keep
info
in
mind
wondering
if
how
it
will
be
used
again
but
in
this
case
info
is
only
used
inside
the
if
statement
in
c
we
can
actually
define
info
in
the
conditional
expression
if
paymentinfo
info
database
readpaymentinfo
cout
user
paid
info
amount
endl
now
the
reader
can
easily
forget
about
info
after
it
goes
out
of
scope
chapter
nine
creating
private
variables
in
javascript
suppose
you
have
a
persistent
variable
that
s
used
by
only
one
function
submitted
false
note
global
variable
var
submit
form
function
form
name
if
submitted
return
don
t
double
submit
the
form
submitted
true
global
variables
like
submitted
can
cause
the
person
reading
this
code
a
lot
of
angst
it
seems
like
submit
form
is
the
only
function
that
uses
submitted
but
you
can
t
know
for
sure
in
fact
another
javascript
file
might
be
using
a
global
variable
named
submitted
too
for
a
different
purpose
you
can
prevent
this
issue
by
wrapping
submitted
inside
a
closure
var
submit
form
function
var
submitted
false
note
can
only
be
accessed
by
the
function
below
return
function
form
name
if
submitted
return
don
t
double
submit
the
form
submitted
true
note
the
parentheses
on
the
last
line
the
anonymous
outer
function
is
immediately
executed
returning
the
inner
function
if
you
haven
t
seen
this
technique
before
it
may
look
strange
at
first
it
has
the
effect
of
making
a
private
scope
that
only
the
inner
function
can
access
now
the
reader
doesn
t
have
to
wonder
where
else
does
submitted
get
used
or
worry
about
conflicting
with
other
globals
of
the
same
name
see
javascript
the
good
parts
by
douglas
crockford
o
reilly
for
more
techniques
like
this
variables
and
readability
javascript
global
scope
in
javascript
if
you
omit
the
keyword
var
from
a
variable
definition
e
g
x
instead
of
var
x
the
variable
is
put
into
the
global
scope
where
every
javascript
file
and
script
block
can
access
it
here
is
an
example
script
var
f
function
danger
i
is
not
declared
with
var
for
i
i
i
f
script
this
code
inadvertently
puts
i
into
the
global
scope
so
a
later
block
can
still
see
it
script
alert
i
script
alerts
i
is
a
global
variable
many
programmers
aren
t
aware
of
this
scoping
rule
and
this
surprising
behavior
can
cause
strange
bugs
a
common
manifestation
of
this
bug
is
when
two
functions
both
create
a
local
variable
with
the
same
name
but
forget
to
use
var
these
functions
will
unknowingly
cross
talk
and
the
poor
programmer
might
conclude
that
his
computer
is
possessed
or
that
his
ram
has
gone
bad
the
common
best
practice
for
javascript
is
to
always
define
variables
using
the
var
keyword
e
g
var
x
this
practice
limits
the
scope
of
the
variable
to
the
innermost
function
where
it
s
defined
no
nested
scope
in
python
and
javascript
languages
like
c
and
java
have
block
scope
where
variables
defined
inside
an
if
for
try
or
similar
structure
are
confined
to
the
nested
scope
of
that
block
if
int
x
x
compile
error
x
is
undefined
but
in
python
and
javascript
variables
defined
in
a
block
spill
out
to
the
whole
function
for
example
notice
the
use
of
example
value
in
this
perfectly
valid
python
code
no
use
of
example
value
up
to
this
point
if
request
for
value
in
request
values
if
value
example
value
value
break
for
logger
in
debug
loggers
logger
log
example
example
value
chapter
nine
this
scoping
rule
is
surprising
to
many
programmers
and
code
like
this
is
harder
to
read
in
other
languages
it
would
be
easier
to
find
where
example
value
was
first
defined
you
would
look
along
the
left
hand
edge
of
the
function
you
re
inside
the
previous
example
is
also
buggy
if
example
value
is
not
set
in
the
first
part
of
the
code
the
second
part
will
raise
an
exception
nameerror
example
value
is
not
defined
we
can
fix
this
and
make
the
code
more
readable
by
defining
example
value
at
the
closest
common
ancestor
in
terms
of
nesting
to
where
it
s
used
example
value
none
if
request
for
value
in
request
values
if
value
example
value
value
break
if
example
value
for
logger
in
debug
loggers
logger
log
example
example
value
however
this
is
a
case
where
example
value
can
be
eliminated
altogether
example
value
is
just
holding
an
intermediate
result
and
as
we
saw
in
eliminating
intermediate
results
on
page
variables
like
these
can
often
be
eliminated
by
completing
the
task
as
soon
as
possible
in
this
case
that
means
logging
the
example
value
as
soon
as
we
find
it
here
s
what
the
new
code
looks
like
def
logexample
value
for
logger
in
debug
loggers
logger
log
example
value
if
request
for
value
in
request
values
if
value
logexample
value
deal
with
value
immediately
break
moving
definitions
down
the
original
c
programming
language
required
all
variable
definitions
to
be
at
the
top
of
the
function
or
block
this
requirement
was
unfortunate
because
for
long
functions
with
many
variables
it
forced
the
reader
to
think
about
all
those
variables
right
away
even
if
they
weren
t
used
until
much
later
c
and
c
removed
this
requirement
in
the
following
example
all
the
variables
are
innocently
defined
at
the
top
of
the
function
def
viewfilteredreplies
original
id
filtered
replies
root
message
messages
objects
get
original
id
all
replies
messages
objects
select
root
id
original
id
variables
and
readability
root
message
view
count
root
message
last
view
time
datetime
datetime
now
root
message
save
for
reply
in
all
replies
if
reply
spam
votes
max
spam
votes
filtered
replies
append
reply
return
filtered
replies
the
problem
with
this
example
code
is
that
it
forces
the
reader
to
think
about
three
variables
at
once
and
switch
gears
between
them
because
the
reader
doesn
t
need
to
know
about
all
of
them
until
later
it
s
easy
to
just
move
each
definition
right
before
its
first
use
def
viewfilteredreplies
original
id
root
message
messages
objects
get
original
id
root
message
view
count
root
message
last
view
time
datetime
datetime
now
root
message
save
all
replies
messages
objects
select
root
id
original
id
filtered
replies
for
reply
in
all
replies
if
reply
spam
votes
max
spam
votes
filtered
replies
append
reply
return
filtered
replies
you
might
be
wondering
whether
all
replies
is
a
necessary
variable
or
if
it
could
be
eliminated
by
doing
for
reply
in
messages
objects
select
root
id
original
id
in
this
case
all
replies
is
a
pretty
good
explaining
variable
so
we
decided
to
keep
it
chapter
nine
prefer
write
once
variables
so
far
in
this
chapter
we
ve
discussed
how
it
s
harder
to
understand
programs
with
lots
of
variables
in
play
well
it
s
even
harder
to
think
about
variables
that
are
constantly
changing
keeping
track
of
their
values
adds
an
extra
degree
of
difficulty
to
combat
this
problem
we
have
a
suggestion
that
may
sound
a
little
strange
prefer
writeonce
variables
variables
that
are
a
permanent
fixture
are
easier
to
think
about
certainly
constants
like
static
const
int
num
threads
variables
and
readability
don
t
require
much
thought
on
the
reader
s
part
and
for
the
same
reason
use
of
const
in
c
and
final
in
java
is
highly
encouraged
in
fact
in
many
languages
including
python
and
java
some
built
in
types
like
string
are
immutable
as
james
gosling
java
s
creator
said
immutables
tend
to
more
often
be
trouble
free
but
even
if
you
can
t
make
your
variable
write
once
it
still
helps
if
the
variable
changes
in
fewer
places
key
idea
the
more
places
a
variable
is
manipulated
the
harder
it
is
to
reason
about
its
current
value
so
how
do
you
do
it
how
can
you
change
a
variable
to
be
write
once
well
a
lot
of
times
it
requires
restructuring
the
code
a
bit
as
you
ll
see
in
the
next
example
a
final
example
for
the
final
example
of
the
chapter
we
d
like
to
show
an
example
demonstrating
many
of
the
principles
we
ve
discussed
so
far
suppose
you
have
a
web
page
with
a
number
of
input
text
fields
arranged
like
this
input
input
input
input
type
text
type
text
type
text
type
text
id
input
id
input
id
input
id
input
value
dustin
value
trevor
value
value
melissa
as
you
can
see
the
ids
start
with
input
and
increment
from
there
your
job
is
to
write
a
function
named
setfirstemptyinput
that
takes
a
string
and
puts
it
in
the
first
empty
input
on
the
page
in
the
example
shown
input
the
function
should
return
the
dom
element
that
was
updated
or
null
if
there
were
no
empty
inputs
left
here
is
some
code
to
do
this
that
doesn
t
apply
the
principles
in
this
chapter
var
setfirstemptyinput
function
new
value
var
found
false
var
i
var
elem
document
getelementbyid
input
i
while
elem
null
if
elem
value
found
true
break
i
elem
document
getelementbyid
input
i
chapter
nine
if
found
elem
value
new
value
return
elem
this
code
gets
the
job
done
but
it
s
not
pretty
what
s
wrong
with
it
and
how
do
we
improve
it
there
are
a
lot
of
ways
to
think
about
improving
this
code
but
we
re
going
to
consider
it
from
the
perspective
of
the
variables
it
uses
var
found
var
i
var
elem
all
three
of
these
variables
exist
for
the
entire
function
and
are
written
to
multiple
times
let
s
try
to
improve
the
use
of
each
of
them
as
we
discussed
earlier
in
the
chapter
intermediate
variables
like
found
can
often
be
eliminated
by
returning
early
here
s
that
improvement
var
setfirstemptyinput
function
new
value
var
i
var
elem
document
getelementbyid
input
i
while
elem
null
if
elem
value
elem
value
new
value
return
elem
i
elem
document
getelementbyid
input
i
return
null
next
take
a
look
at
elem
it
s
used
multiple
times
throughout
the
code
in
a
very
loopy
way
where
it
s
hard
to
keep
track
of
its
value
the
code
makes
it
seem
as
if
elem
is
the
value
we
re
iterating
through
when
really
we
re
just
incrementing
through
i
so
let
s
restructure
the
while
loop
into
a
for
loop
over
i
var
setfirstemptyinput
function
new
value
for
var
i
true
i
var
elem
document
getelementbyid
input
i
if
elem
null
return
null
search
failed
no
empty
input
found
if
elem
value
elem
value
new
value
return
elem
variables
and
readability
in
particular
notice
how
elem
acts
as
a
write
once
variable
whose
lifespan
is
contained
inside
the
loop
the
use
of
true
as
a
for
loop
condition
is
unusual
but
in
exchange
we
are
able
to
see
the
definition
and
modifications
of
i
in
a
single
line
a
traditional
while
true
would
also
be
reasonable
summary
this
chapter
is
about
how
the
variables
in
a
program
can
quickly
accumulate
and
become
too
much
to
keep
track
of
you
can
make
your
code
easier
to
read
by
having
fewer
variables
and
making
them
as
lightweight
as
possible
specifically
eliminate
variables
that
just
get
in
the
way
in
particular
we
showed
a
few
examples
of
how
to
eliminate
intermediate
result
variables
by
handling
the
result
immediately
reduce
the
scope
of
each
variable
to
be
as
small
as
possible
move
each
variable
to
a
place
where
the
fewest
lines
of
code
can
see
it
out
of
sight
is
out
of
mind
prefer
write
once
variables
variables
that
are
set
only
once
or
const
final
or
otherwise
immutable
make
code
easier
to
understand
chapter
nine
part
iii
reorganizing
your
code
in
part
ii
we
discussed
how
to
change
the
loops
and
logic
of
your
program
to
make
your
code
more
readable
we
described
several
techniques
that
required
changing
the
structure
of
your
program
in
minor
ways
in
this
part
we
ll
discuss
larger
changes
you
can
make
to
your
code
at
the
function
level
specifically
we
ll
cover
three
ways
to
reorganize
your
code
extract
unrelated
subproblems
that
aren
t
related
to
the
primary
goal
of
your
program
rearrange
your
code
so
it
s
doing
only
one
task
at
a
time
describe
your
code
in
words
first
and
use
this
description
to
help
guide
you
to
a
cleaner
solution
finally
we
ll
discuss
situations
where
you
can
remove
code
entirely
or
avoid
writing
it
in
the
first
place
the
single
best
way
to
make
code
easy
to
understand
chapter
ten
extracting
unrelated
subproblems
engineering
is
all
about
breaking
down
big
problems
into
smaller
ones
and
putting
the
solutions
for
those
problems
back
together
applying
this
principle
to
code
makes
it
more
robust
and
easier
to
read
the
advice
for
this
chapter
is
to
aggressively
identify
and
extract
unrelated
subproblems
here
s
what
we
mean
look
at
a
given
function
or
block
of
code
and
ask
yourself
what
is
the
high
level
goal
of
this
code
for
each
line
of
code
ask
is
it
working
directly
to
that
goal
or
is
it
solving
an
unrelated
subproblem
needed
to
meet
it
if
enough
lines
are
solving
an
unrelated
subproblem
extract
that
code
into
a
separate
function
extracting
code
into
separate
functions
is
something
you
probably
do
every
day
but
for
this
chapter
we
decided
to
focus
on
the
specific
case
of
extracting
unrelated
subproblems
where
the
extracted
code
is
blissfully
unaware
of
why
it
s
being
called
as
you
ll
see
it
s
an
easy
technique
to
apply
but
can
improve
your
code
substantially
yet
for
some
reason
many
programmers
don
t
use
this
technique
enough
the
trick
is
to
actively
look
for
these
unrelated
subproblems
in
this
chapter
we
will
go
through
a
variety
of
examples
that
illustrate
this
technique
for
different
situations
you
might
run
into
introductory
example
findclosestlocation
the
high
level
goal
of
the
following
javascript
code
is
find
the
location
that
s
closest
to
a
given
point
don
t
get
bogged
down
by
the
advanced
geometry
which
we
ve
italicized
return
which
element
of
array
is
closest
to
the
given
latitude
longitude
models
the
earth
as
a
perfect
sphere
var
findclosestlocation
function
lat
lng
array
var
closest
var
closest
dist
number
max
value
for
var
i
i
array
length
i
convert
both
points
to
radians
var
lat
rad
radians
lat
var
lng
rad
radians
lng
var
lat
rad
radians
array
i
latitude
var
lng
rad
radians
array
i
longitude
use
the
spherical
law
of
cosines
formula
var
dist
math
acos
math
sin
lat
rad
math
sin
lat
rad
math
cos
lat
rad
math
cos
lat
rad
math
cos
lng
rad
lng
rad
if
dist
closest
dist
closest
array
i
chapter
ten
closest
dist
dist
return
closest
most
of
the
code
inside
the
loop
is
working
on
an
unrelated
subproblem
compute
the
spherical
distance
between
two
lat
long
points
because
there
is
so
much
of
that
code
it
makes
sense
to
extract
it
into
a
separate
spherical
distance
function
var
spherical
distance
function
lat
lng
lat
lng
var
lat
rad
radians
lat
var
lng
rad
radians
lng
var
lat
rad
radians
lat
var
lng
rad
radians
lng
use
the
spherical
law
of
cosines
formula
return
math
acos
math
sin
lat
rad
math
sin
lat
rad
math
cos
lat
rad
math
cos
lat
rad
math
cos
lng
rad
lng
rad
now
the
remaining
code
becomes
var
findclosestlocation
function
lat
lng
array
var
closest
var
closest
dist
number
max
value
for
var
i
i
array
length
i
var
dist
spherical
distance
lat
lng
array
i
latitude
array
i
longitude
if
dist
closest
dist
closest
array
i
closest
dist
dist
return
closest
this
code
is
far
more
readable
because
the
reader
can
focus
on
the
high
level
goal
without
getting
distracted
by
intense
geometry
equations
as
an
added
bonus
spherical
distance
will
be
easier
to
test
in
isolation
and
spherical
distance
is
the
type
of
function
that
could
be
reused
in
the
future
this
is
why
it
s
an
unrelated
subproblem
it
s
completely
self
contained
and
unaware
of
how
applications
are
using
it
pure
utility
code
there
is
a
core
set
of
basic
tasks
that
most
programs
do
such
as
manipulating
strings
using
hash
tables
and
reading
writing
files
extracting
unrelated
subproblems
often
these
basic
utilities
are
implemented
by
the
built
in
libraries
in
your
programming
language
for
instance
if
you
want
to
read
the
entire
contents
of
a
file
in
php
you
can
call
file
get
contents
filename
or
in
python
you
can
do
open
filename
read
but
sometimes
you
have
to
fill
in
the
gaps
yourself
in
c
for
instance
there
is
no
succinct
way
to
read
an
entire
file
instead
you
inevitably
end
up
writing
code
like
this
ifstream
file
file
name
calculate
the
file
s
size
and
allocate
a
buffer
of
that
size
file
seekg
ios
end
const
int
file
size
file
tellg
char
file
buf
new
char
file
size
read
the
entire
file
into
the
buffer
file
seekg
ios
beg
file
read
file
buf
file
size
file
close
this
is
a
classic
example
of
an
unrelated
subproblem
that
should
be
extracted
into
a
new
function
like
readfiletostring
now
the
rest
of
your
codebase
can
act
as
if
c
did
have
a
readfiletostring
function
in
general
if
you
find
yourself
thinking
i
wish
our
library
had
an
xyz
function
go
ahead
and
write
it
assuming
it
doesn
t
already
exist
over
time
you
ll
build
up
a
nice
collection
of
utility
code
that
can
be
used
across
projects
other
general
purpose
code
when
debugging
javascript
programmers
often
use
alert
to
pop
up
a
message
box
that
displays
some
information
to
the
programmer
the
web
s
version
of
printf
debugging
for
example
the
following
function
call
submits
data
to
the
server
using
ajax
and
then
displays
the
dictionary
returned
from
the
server
ajax
post
url
http
example
com
submit
data
data
on
success
function
response
data
var
str
n
for
var
key
in
response
data
str
key
response
data
key
n
alert
str
continue
handling
response
data
chapter
ten
the
high
level
goal
of
this
code
is
make
an
ajax
call
to
the
server
and
handle
the
response
but
a
lot
of
the
code
is
solving
the
unrelated
subproblem
pretty
print
a
dictionary
it
s
easy
to
extract
that
code
into
a
function
like
format
pretty
obj
var
format
pretty
function
obj
var
str
n
for
var
key
in
obj
str
key
obj
key
n
return
str
unexpected
benefits
there
are
a
lot
of
reasons
why
extracting
format
pretty
is
a
good
idea
it
makes
the
calling
code
simpler
and
format
pretty
is
a
handy
function
to
have
around
but
there
s
another
great
reason
that
s
not
as
obvious
it
s
easier
to
improve
format
pretty
when
the
code
is
by
itself
when
you
re
working
on
a
smaller
function
in
isolation
it
feels
easier
to
add
features
improve
reliability
take
care
of
edge
cases
and
so
on
here
are
some
cases
format
pretty
obj
doesn
t
handle
it
expects
obj
to
be
an
object
if
instead
it
s
a
plain
string
or
undefined
the
current
code
will
throw
an
exception
it
expects
each
value
of
obj
to
be
a
simple
type
if
instead
it
contains
nested
objects
the
current
code
will
display
them
as
object
object
which
isn
t
very
pretty
before
we
separated
format
pretty
into
its
own
function
it
would
have
felt
like
a
lot
of
work
to
make
all
these
improvements
in
fact
recursively
printing
nested
objects
is
very
difficult
without
a
separate
function
but
now
adding
this
functionality
is
easy
here
s
what
the
improved
code
looks
like
var
format
pretty
function
obj
indent
handle
null
undefined
strings
and
non
objects
if
obj
null
return
null
if
obj
undefined
return
undefined
if
typeof
obj
string
return
obj
if
typeof
obj
object
return
string
obj
if
indent
undefined
indent
handle
non
null
objects
var
str
n
for
var
key
in
obj
str
indent
key
str
format
pretty
obj
key
indent
return
str
indent
n
extracting
unrelated
subproblems
this
covers
the
shortcomings
listed
previously
and
produces
output
like
this
key
key
key
key
key
true
undefined
null
key
a
key
a
hello
world
create
a
lot
of
general
purpose
code
the
functions
readfiletostring
and
format
pretty
are
great
examples
of
unrelated
subproblems
they
re
so
basic
and
widely
applicable
that
they
are
likely
to
be
reused
across
projects
codebases
often
have
a
special
directory
for
code
like
this
e
g
util
so
that
it
can
be
easily
shared
general
purpose
code
is
great
because
it
s
completely
decoupled
from
the
rest
of
your
project
code
like
this
is
easier
to
develop
easier
to
test
and
easier
to
understand
if
only
all
of
your
code
could
be
like
this
think
about
many
of
the
powerful
libraries
and
systems
that
you
use
such
as
sql
databases
javascript
libraries
and
html
templating
systems
you
don
t
have
to
worry
about
their
internals
those
codebases
are
completely
isolated
from
your
project
as
a
result
your
project
s
codebase
remains
small
the
more
of
your
project
you
can
break
away
as
isolated
libraries
the
better
because
the
rest
of
your
code
will
be
smaller
and
easier
to
think
about
is
this
top
down
or
bottom
up
programming
top
down
programming
is
a
style
where
the
highest
level
modules
and
functions
are
designed
first
and
the
lower
level
functions
are
implemented
as
needed
to
support
them
bottom
up
programming
tries
to
anticipate
and
solve
all
the
subproblems
first
and
then
build
the
higher
level
components
using
these
pieces
this
chapter
isn
t
advocating
one
method
over
the
other
most
programming
involves
a
combination
of
both
what
s
important
is
the
end
result
subproblems
are
removed
and
tackled
separately
chapter
ten
project
specific
functionality
ideally
the
subproblems
you
extract
would
be
completely
project
agnostic
but
even
if
they
re
not
that
s
okay
breaking
off
subproblems
still
works
wonders
here
is
an
example
from
a
business
reviews
website
this
python
code
creates
a
new
business
object
and
sets
its
name
url
and
date
created
business
business
business
name
request
post
name
url
path
name
business
name
lower
url
path
name
re
sub
r
url
path
name
url
path
name
re
sub
r
a
z
url
path
name
url
path
name
url
path
name
strip
business
url
biz
url
path
name
business
date
created
datetime
datetime
utcnow
business
save
to
database
the
url
is
supposed
to
be
a
clean
version
of
the
name
for
example
if
the
name
is
a
c
joe
s
tire
smog
inc
the
url
will
be
biz
ac
joes
tire
smog
inc
the
unrelated
subproblem
in
this
code
is
turn
a
name
into
a
valid
url
we
can
extract
this
code
quite
easily
while
we
re
at
it
we
can
also
precompile
the
regular
expressions
and
give
them
readable
names
chars
to
remove
re
compile
r
chars
to
dash
re
compile
r
a
z
def
make
url
friendly
text
text
text
lower
text
chars
to
remove
sub
text
text
chars
to
dash
sub
text
return
text
strip
now
the
original
code
has
a
much
more
regular
pattern
business
business
business
name
request
post
name
business
url
biz
make
url
friendly
business
name
business
date
created
datetime
datetime
utcnow
business
save
to
database
this
code
requires
far
less
effort
to
read
because
you
aren
t
distracted
by
the
regular
expressions
and
deep
string
manipulation
where
should
you
put
the
code
for
make
url
friendly
it
seems
like
a
fairly
general
function
so
it
might
make
sense
to
put
it
in
a
separate
util
directory
on
the
other
hand
those
regular
expressions
were
designed
with
u
s
business
names
in
mind
so
perhaps
the
code
should
stay
in
the
same
file
where
it
s
used
it
actually
doesn
t
matter
that
much
and
you
can
easily
move
the
definition
later
on
what
s
more
important
is
that
make
url
friendly
was
extracted
at
all
extracting
unrelated
subproblems
simplifying
an
existing
interface
everybody
loves
when
a
library
offers
a
clean
interface
one
that
takes
few
arguments
doesn
t
need
much
setup
and
generally
requires
little
effort
to
use
it
makes
your
code
look
elegant
simple
and
powerful
at
the
same
time
but
if
an
interface
you
re
using
isn
t
clean
you
can
still
make
your
own
wrapper
functions
that
are
for
example
dealing
with
browser
cookies
in
javascript
is
far
from
ideal
conceptually
cookies
are
a
set
of
name
value
pairs
but
the
interface
the
browser
provides
presents
a
single
document
cookie
string
whose
syntax
is
name
value
name
value
to
find
the
cookie
you
want
you
re
forced
to
parse
this
giant
string
yourself
here
s
an
example
of
code
that
reads
the
value
for
the
cookie
named
max
results
var
max
results
var
cookies
document
cookie
split
for
var
i
i
cookies
length
i
var
c
cookies
i
c
c
replace
remove
leading
spaces
if
c
indexof
max
results
max
results
number
c
substring
c
length
wow
that
s
some
ugly
code
clearly
there
s
a
get
cookie
function
waiting
to
be
made
so
that
we
can
just
write
var
max
results
number
get
cookie
max
results
creating
or
changing
a
cookie
value
is
even
stranger
you
have
to
set
document
cookie
to
a
value
with
an
exact
syntax
document
cookie
max
results
expires
wed
jan
utc
path
that
statement
looks
like
it
would
overwrite
all
other
existing
cookies
but
magically
it
doesn
t
a
more
ideal
interface
to
setting
a
cookie
would
be
something
like
set
cookie
name
value
days
to
expire
erasing
a
cookie
is
also
unintuitive
you
have
to
set
the
cookie
to
expire
in
the
past
instead
an
ideal
interface
would
be
simply
delete
cookie
name
the
lesson
here
is
that
you
should
never
have
to
settle
for
an
interface
that
s
less
than
ideal
you
can
always
create
your
own
wrapper
functions
to
hide
the
ugly
details
of
an
interface
you
re
stuck
with
chapter
ten
reshaping
an
interface
to
your
needs
a
lot
of
code
in
a
program
is
there
just
to
support
other
code
for
example
setting
up
inputs
to
a
function
or
postprocessing
the
output
this
glue
code
often
has
nothing
to
do
with
the
real
logic
of
your
program
mundane
code
like
this
is
a
great
candidate
to
be
pulled
out
into
separate
functions
for
example
let
s
say
you
have
a
python
dictionary
containing
sensitive
user
information
like
username
password
and
you
need
to
put
all
that
information
into
a
url
because
it
s
sensitive
you
decide
to
encrypt
the
dictionary
first
using
a
cipher
class
but
cipher
expects
a
string
of
bytes
as
input
not
a
dictionary
and
cipher
returns
a
string
of
bytes
but
we
need
something
that
s
url
safe
cipher
also
takes
a
number
of
extra
parameters
and
is
pretty
cumbersome
to
use
what
started
as
a
simple
task
turns
into
a
lot
of
glue
code
user
info
username
password
user
str
json
dumps
user
info
cipher
cipher
aes
cbc
key
private
key
init
vector
init
vector
op
encode
encrypted
bytes
cipher
update
user
str
encrypted
bytes
cipher
final
flush
out
the
current
bit
block
url
http
example
com
user
info
base
urlsafe
b
encode
encrypted
bytes
even
though
the
problem
we
re
tackling
is
encrypt
the
user
s
information
into
a
url
the
majority
of
this
code
is
just
doing
encrypt
this
python
object
into
a
url
friendly
string
it
s
easy
to
extract
that
subproblem
def
url
safe
encrypt
obj
obj
str
json
dumps
obj
cipher
cipher
aes
cbc
key
private
key
init
vector
init
vector
op
encode
encrypted
bytes
cipher
update
obj
str
encrypted
bytes
cipher
final
flush
out
the
current
bit
block
return
base
urlsafe
b
encode
encrypted
bytes
then
the
resulting
code
to
execute
the
real
logic
of
the
program
is
simple
user
info
username
password
url
http
example
com
user
info
url
safe
encrypt
user
info
taking
things
too
far
as
we
said
at
the
beginning
of
the
chapter
our
goal
is
to
aggressively
identify
and
extract
unrelated
subproblems
we
say
aggressively
because
most
coders
aren
t
aggressive
enough
but
it
s
possible
to
get
overexcited
and
take
things
too
far
extracting
unrelated
subproblems
for
example
the
code
from
the
previous
section
could
have
been
broken
down
much
further
like
this
user
info
username
password
url
http
example
com
user
info
url
safe
encrypt
obj
user
info
def
url
safe
encrypt
obj
obj
obj
str
json
dumps
obj
return
url
safe
encrypt
str
obj
str
def
url
safe
encrypt
str
data
encrypted
bytes
encrypt
data
return
base
urlsafe
b
encode
encrypted
bytes
def
encrypt
data
cipher
make
cipher
encrypted
bytes
cipher
update
data
encrypted
bytes
cipher
final
flush
out
any
remaining
bytes
return
encrypted
bytes
def
make
cipher
return
cipher
aes
cbc
key
private
key
init
vector
init
vector
op
encode
introducing
all
these
tiny
functions
actually
hurts
readability
because
the
reader
has
more
to
keep
track
of
and
following
the
path
of
execution
requires
jumping
around
there
is
a
small
but
tangible
readability
cost
of
adding
a
new
function
to
your
code
in
the
previous
case
nothing
is
being
gained
to
offset
this
cost
it
may
make
sense
to
add
these
smaller
functions
if
they
re
needed
by
other
parts
of
your
project
but
until
then
there
is
no
need
summary
a
simple
way
to
think
about
this
chapter
is
to
separate
the
generic
code
from
the
projectspecific
code
as
it
turns
out
most
code
is
generic
by
building
a
large
set
of
libraries
and
helper
functions
to
solve
the
general
problems
what
s
left
will
be
a
small
core
of
what
makes
your
program
unique
the
main
reason
this
technique
helps
is
that
it
lets
the
programmer
focus
on
smaller
welldefined
problems
that
are
detached
from
the
rest
of
your
project
as
a
result
the
solutions
to
those
subproblems
tend
to
be
more
thorough
and
correct
you
might
also
be
able
to
reuse
them
later
chapter
ten
further
reading
martin
fowler
s
refactoring
improving
the
design
of
existing
code
fowler
et
al
addison
wesley
professional
describes
the
extract
method
of
refactoring
and
catalogs
many
other
ways
to
refactor
your
code
kent
beck
s
smalltalk
best
practice
patterns
prentice
hall
describes
the
composed
method
pattern
which
lists
a
number
of
principles
for
breaking
down
your
code
into
lots
of
little
functions
in
particular
one
of
the
principles
is
keep
all
of
the
operations
in
a
single
method
at
the
same
level
of
abstraction
these
ideas
are
similar
to
our
advice
of
extracting
unrelated
subproblems
what
we
discussed
in
this
chapter
is
a
simple
and
particular
case
of
when
to
extract
a
method
extracting
unrelated
subproblems
chapter
eleven
one
task
at
a
time
code
that
does
multiple
things
at
once
is
harder
to
understand
a
single
block
of
code
might
be
initializing
new
objects
cleansing
data
parsing
inputs
and
applying
business
logic
all
at
the
same
time
if
all
that
code
is
woven
together
it
will
be
harder
to
understand
than
if
each
task
is
started
and
completed
on
its
own
key
idea
code
should
be
organized
so
that
it
s
doing
only
one
task
at
a
time
said
another
way
this
chapter
is
about
defragmenting
your
code
the
following
diagram
illustrates
this
process
the
left
side
shows
the
various
tasks
a
piece
of
code
is
doing
and
the
right
side
shows
that
same
code
after
it
s
been
organized
to
do
one
task
at
a
time
you
might
have
heard
the
advice
that
functions
should
do
only
one
thing
our
advice
is
similar
but
isn
t
always
about
function
boundaries
sure
breaking
a
large
function
into
multiple
smaller
functions
can
be
good
but
even
if
you
don
t
do
this
you
can
still
organize
the
code
inside
that
large
function
so
it
feels
like
there
are
separate
logical
sections
here
s
the
process
we
use
to
make
code
do
one
task
at
a
time
list
out
all
the
tasks
your
code
is
doing
we
use
the
word
task
very
loosely
it
could
be
as
small
as
make
sure
this
object
is
valid
or
as
vague
as
iterate
through
every
node
in
the
tree
try
to
separate
those
tasks
as
much
as
you
can
into
different
functions
or
at
least
different
sections
of
code
in
this
chapter
we
ll
show
you
a
number
of
examples
of
how
to
do
this
chapter
eleven
tasks
can
be
small
suppose
there
s
a
voting
widget
on
a
blog
where
a
user
can
vote
a
comment
up
or
down
the
total
score
of
a
comment
is
the
sum
over
all
votes
for
each
up
vote
for
each
down
vote
here
are
the
three
states
a
user
s
vote
can
be
in
and
how
it
would
affect
the
total
score
when
the
user
clicks
one
of
the
buttons
to
make
change
her
vote
the
following
javascript
is
called
vote
changed
old
vote
new
vote
each
vote
is
up
down
or
this
function
updates
the
total
score
and
works
for
all
combinations
of
old
vote
new
vote
var
vote
changed
function
old
vote
new
vote
var
score
get
score
if
new
vote
old
vote
if
new
vote
up
score
old
vote
down
else
if
new
vote
down
score
old
vote
up
else
if
new
vote
score
old
vote
up
set
score
score
even
though
the
code
is
pretty
short
it
s
doing
a
lot
there
are
lots
of
intricate
details
and
it
s
hard
to
tell
at
a
glance
whether
there
are
any
off
by
one
errors
typos
or
other
bugs
the
code
may
seem
to
be
doing
only
one
thing
updating
the
score
but
there
are
actually
two
tasks
being
performed
at
once
old
vote
and
new
vote
are
being
parsed
into
numerical
values
score
is
being
updated
we
can
make
the
code
easier
to
read
by
solving
each
task
separately
the
following
code
solves
the
first
task
of
parsing
the
vote
into
a
numerical
value
var
vote
value
function
vote
if
vote
up
one
task
at
a
time
return
if
vote
down
return
return
now
the
rest
of
the
code
can
solve
the
second
task
updating
score
var
vote
changed
function
old
vote
new
vote
var
score
get
score
score
vote
value
old
vote
remove
the
old
vote
score
vote
value
new
vote
add
the
new
vote
set
score
score
as
you
can
see
this
version
of
the
code
takes
a
lot
less
mental
effort
to
convince
yourself
that
it
works
that
s
a
big
part
of
what
makes
code
easy
to
understand
extracting
values
from
an
object
we
once
had
some
javascript
that
formatted
a
user
s
location
into
a
friendly
string
of
city
country
like
santa
monica
usa
or
paris
france
we
were
given
a
location
info
dictionary
with
plenty
of
structured
information
all
we
had
to
do
was
pick
a
city
and
a
country
from
all
the
fields
and
concatenate
them
together
the
following
illustration
shows
example
input
output
it
seems
easy
so
far
but
the
tricky
part
is
that
any
or
all
of
these
four
values
might
be
missing
here
s
how
we
dealt
with
that
when
choosing
the
city
we
preferred
to
use
the
localityname
city
town
if
available
then
the
subadministrativeareaname
larger
city
county
then
the
administrativeareaname
state
territory
chapter
eleven
if
all
three
were
missing
the
city
was
affectionately
given
the
default
middle
ofnowhere
if
the
countryname
was
missing
planet
earth
was
used
as
a
default
the
following
figure
shows
two
examples
of
handling
missing
values
here
is
the
code
we
wrote
to
implement
this
task
var
place
location
info
localityname
e
g
santa
monica
if
place
place
location
info
subadministrativeareaname
e
g
los
angeles
if
place
place
location
info
administrativeareaname
e
g
california
if
place
place
middle
of
nowhere
if
location
info
countryname
place
location
info
countryname
e
g
usa
else
place
planet
earth
return
place
sure
it
s
a
little
messy
but
it
got
the
job
done
but
a
few
days
later
we
needed
to
improve
the
functionality
for
locations
in
the
united
states
we
wanted
to
display
the
state
instead
of
the
country
if
possible
so
instead
of
santa
monica
usa
it
would
return
santa
monica
california
adding
this
feature
to
the
previous
code
would
have
made
it
much
uglier
applying
one
task
at
a
time
rather
than
bend
this
code
to
our
will
we
stopped
and
realized
that
it
was
already
doing
multiple
tasks
at
the
same
time
one
task
at
a
time
extracting
values
from
the
dictionary
location
info
going
through
a
preference
order
for
city
defaulting
to
middle
of
nowhere
if
it
couldn
t
find
anything
getting
the
country
and
using
planet
earth
if
there
wasn
t
one
updating
place
so
instead
we
rewrote
the
original
code
to
solve
each
of
these
tasks
independently
the
first
task
extracting
values
from
location
info
was
easy
to
solve
on
its
own
var
var
var
var
town
city
state
country
location
info
localityname
location
info
subadministrativeareaname
location
info
administrativeareaname
location
info
countryname
e
g
e
g
e
g
e
g
santa
monica
los
angeles
ca
usa
at
this
point
we
were
done
using
location
info
and
didn
t
have
to
remember
those
long
and
unintuitive
keys
instead
we
had
four
simple
variables
to
work
with
next
we
had
to
figure
out
what
the
second
half
of
the
return
value
would
be
start
with
the
default
and
keep
overwriting
with
the
most
specific
value
var
second
half
planet
earth
if
country
second
half
country
if
state
country
usa
second
half
state
similarly
we
could
figure
out
the
first
half
var
first
half
middle
of
nowhere
if
state
country
usa
first
half
state
if
city
first
half
city
if
town
first
half
town
finally
we
pieced
the
information
together
return
first
half
second
half
the
defragmentation
illustration
at
the
beginning
of
this
chapter
was
actually
a
representation
of
the
original
solution
and
this
new
version
here
s
that
same
illustration
with
more
details
filled
in
chapter
eleven
as
you
can
see
the
four
tasks
in
the
second
solution
have
been
defragmented
into
distinct
regions
another
approach
when
refactoring
code
there
are
often
multiple
ways
to
do
it
and
this
case
is
no
exception
once
you
ve
separated
some
of
the
tasks
the
code
gets
easier
to
think
about
and
you
might
come
up
with
even
better
ways
to
refactor
it
for
instance
that
earlier
series
of
if
statements
requires
some
careful
reading
to
know
if
every
case
works
correctly
there
are
actually
two
subtasks
going
on
simultaneously
in
that
code
go
through
a
list
of
variables
and
pick
the
most
preferred
one
that
s
available
use
a
different
list
depending
on
whether
the
country
is
usa
looking
back
you
can
see
that
the
earlier
code
has
the
if
usa
logic
interwoven
with
the
rest
of
the
logic
instead
we
can
handle
the
usa
and
non
usa
cases
separately
var
first
half
second
half
if
country
usa
first
half
town
city
middle
of
nowhere
second
half
state
usa
else
first
half
town
city
state
middle
of
nowhere
second
half
country
planet
earth
return
first
half
second
half
in
case
you
aren
t
familiar
with
javascript
a
b
c
is
idiomatic
and
evaluates
to
the
first
truthy
value
in
this
case
a
defined
nonempty
string
this
code
has
the
benefit
that
it
s
very
one
task
at
a
time
easy
to
inspect
the
preference
list
and
update
it
most
of
the
if
statements
have
been
swept
away
and
the
business
logic
is
represented
by
fewer
lines
of
code
a
larger
example
in
a
web
crawling
system
we
built
a
function
named
updatecounts
was
called
to
increment
various
statistics
after
each
web
page
was
downloaded
void
updatecounts
httpdownload
hd
counts
exit
state
hd
exit
state
counts
http
response
hd
http
response
counts
content
type
hd
content
type
e
g
success
or
failure
e
g
not
found
e
g
text
html
well
that
s
how
we
wish
the
code
looked
in
actuality
the
httpdownload
object
had
none
of
the
methods
shown
here
instead
httpdownload
was
a
very
large
and
complex
class
with
many
nested
classes
and
we
had
to
fish
out
those
values
ourselves
to
make
matters
worse
sometimes
those
values
were
missing
altogether
in
which
case
we
just
used
unknown
as
the
default
value
because
of
all
this
the
real
code
was
quite
a
mess
warning
do
not
stare
directly
at
this
code
for
extended
periods
of
time
void
updatecounts
httpdownload
hd
figure
out
the
exit
state
if
available
if
hd
has
event
log
hd
event
log
has
exit
state
counts
exit
state
unknown
else
string
state
str
exitstatetypename
hd
event
log
exit
state
counts
exit
state
state
str
if
there
are
no
http
headers
at
all
use
unknown
for
the
remaining
elements
if
hd
has
http
headers
counts
http
response
unknown
counts
content
type
unknown
return
httpheaders
headers
hd
http
headers
log
the
http
response
if
known
otherwise
log
unknown
if
headers
has
response
code
counts
http
response
unknown
else
string
code
stringprintf
d
headers
response
code
counts
http
response
code
log
the
content
type
if
known
otherwise
log
unknown
if
headers
has
content
type
counts
content
type
unknown
chapter
eleven
else
string
content
type
contenttypemime
headers
content
type
counts
content
type
content
type
as
you
can
see
there
s
a
lot
of
code
and
a
lot
of
logic
and
even
a
few
repeated
lines
of
code
this
code
is
not
fun
to
read
in
particular
this
code
switches
back
and
forth
between
different
tasks
here
are
the
different
tasks
interleaved
throughout
the
code
using
unknown
as
the
default
value
for
each
key
detecting
whether
members
of
httpdownload
are
missing
extracting
the
value
and
converting
it
to
a
string
updating
counts
we
can
improve
the
code
by
separating
some
of
these
tasks
into
distinct
regions
in
the
code
void
updatecounts
httpdownload
hd
task
define
default
values
for
each
of
the
values
we
want
to
extract
string
exit
state
unknown
string
http
response
unknown
string
content
type
unknown
task
try
to
extract
each
value
from
httpdownload
one
by
one
if
hd
has
event
log
hd
event
log
has
exit
state
exit
state
exitstatetypename
hd
event
log
exit
state
if
hd
has
http
headers
hd
http
headers
has
response
code
http
response
stringprintf
d
hd
http
headers
response
code
if
hd
has
http
headers
hd
http
headers
has
content
type
content
type
contenttypemime
hd
http
headers
content
type
task
update
counts
counts
exit
state
exit
state
counts
http
response
http
response
counts
content
type
content
type
as
you
can
see
the
code
has
three
separate
regions
with
the
following
aims
define
defaults
for
the
three
keys
we
are
interested
in
extract
the
values
if
available
for
each
of
these
keys
and
convert
them
to
strings
update
counts
for
each
key
value
what
s
good
about
these
regions
is
that
they
re
isolated
from
one
another
while
you
re
reading
one
region
you
don
t
need
to
think
about
the
other
regions
one
task
at
a
time
note
that
although
we
listed
four
tasks
we
were
able
to
separate
only
three
of
them
that
s
perfectly
fine
the
tasks
you
list
initially
are
just
a
starting
point
even
separating
some
of
them
can
help
things
a
lot
as
it
did
here
further
improvements
this
new
version
of
the
code
is
a
marked
improvement
from
the
original
monstrosity
and
notice
that
we
didn
t
even
have
to
create
other
functions
to
perform
this
cleanup
as
we
mentioned
before
the
idea
of
one
task
at
a
time
can
help
you
clean
up
code
regardless
of
function
boundaries
however
we
could
also
have
improved
this
code
another
way
by
introducing
three
helper
functions
void
updatecounts
httpdownload
hd
counts
exit
state
exitstate
hd
counts
http
response
httpresponse
hd
counts
content
type
contenttype
hd
these
functions
would
extract
the
corresponding
value
or
return
unknown
for
example
string
exitstate
httpdownload
hd
if
hd
has
event
log
hd
event
log
has
exit
state
return
exitstatetypename
hd
event
log
exit
state
else
return
unknown
notice
that
this
alternative
solution
doesn
t
even
define
any
variables
as
we
mentioned
in
chapter
variables
and
readability
variables
that
hold
intermediate
results
can
often
be
eliminated
entirely
in
this
solution
we
ve
simply
sliced
the
problem
in
a
different
direction
both
solutions
are
highly
readable
as
they
require
the
reader
to
think
about
only
one
task
at
a
time
summary
this
chapter
illustrates
a
simple
technique
for
organizing
your
code
do
only
one
task
at
a
time
if
you
have
code
that
s
difficult
to
read
try
to
list
all
of
the
tasks
it
s
doing
some
of
these
tasks
might
easily
become
separate
functions
or
classes
others
might
just
become
logical
paragraphs
within
a
single
function
the
exact
details
of
how
you
separate
these
tasks
isn
t
as
important
as
the
fact
that
they
re
separated
the
hard
part
is
accurately
describing
all
the
little
things
your
program
is
doing
chapter
eleven
chapter
twelve
turning
thoughts
into
code
you
do
not
really
understand
something
unless
you
can
explain
it
to
your
grandmother
albert
einstein
when
explaining
a
complex
idea
to
someone
it
s
easy
to
confuse
them
with
all
the
little
details
it
s
a
valuable
skill
to
be
able
to
explain
an
idea
in
plain
english
so
that
someone
less
knowledgeable
than
you
can
understand
it
requires
distilling
an
idea
down
to
the
most
important
concepts
doing
this
not
only
helps
the
other
person
understand
but
also
helps
you
think
about
your
own
ideas
more
clearly
the
same
skill
should
be
used
when
presenting
code
to
your
reader
we
take
the
view
that
source
code
is
the
primary
way
to
explain
what
a
program
is
doing
so
the
code
should
be
written
in
plain
english
in
this
chapter
we
ll
use
a
simple
process
that
can
help
you
code
more
clearly
describe
what
code
needs
to
do
in
plain
english
as
you
would
to
a
colleague
pay
attention
to
the
key
words
and
phrases
used
in
this
description
write
your
code
to
match
this
description
describing
logic
clearly
here
is
a
snippet
of
code
from
a
web
page
in
php
this
code
is
at
the
top
of
a
secured
page
it
checks
whether
the
user
is
authorized
to
see
the
page
and
if
not
immediately
returns
a
page
telling
the
user
she
is
not
authorized
is
admin
is
admin
request
if
document
if
is
admin
document
username
session
username
return
not
authorized
else
if
is
admin
return
not
authorized
continue
rendering
the
page
there
s
quite
a
bit
of
logic
in
this
code
as
you
saw
in
part
ii
simplifying
loops
and
logic
large
logic
trees
like
this
aren
t
easy
to
understand
the
logic
in
this
code
can
probably
be
simplified
but
how
let
s
start
by
describing
the
logic
in
plain
english
there
are
two
ways
you
can
be
authorized
you
are
an
admin
you
own
the
current
document
if
there
is
one
otherwise
you
are
not
authorized
chapter
twelve
here
is
an
alternative
solution
inspired
by
this
description
if
is
admin
request
authorized
elseif
document
document
username
session
username
authorized
else
return
not
authorized
continue
rendering
the
page
this
version
is
slightly
unusual
because
it
has
two
empty
bodies
but
the
code
is
smaller
and
the
logic
is
simpler
because
there
is
no
negation
the
previous
solution
had
three
nots
the
bottom
line
is
that
it
s
easier
to
understand
knowing
your
libraries
helps
we
once
had
a
website
that
included
a
tips
box
that
showed
the
user
helpful
suggestions
like
tip
log
in
to
see
your
past
queries
show
me
another
tip
there
were
a
few
dozen
tips
and
all
of
them
were
hidden
inside
the
html
div
id
tip
class
tip
tip
log
in
to
see
your
past
queries
div
div
id
tip
class
tip
tip
click
on
a
picture
to
see
it
close
up
div
when
a
user
visited
the
page
one
of
these
divs
was
randomly
made
visible
and
the
rest
stayed
hidden
if
the
show
me
another
tip
link
was
clicked
it
cycled
to
the
next
tip
here
is
some
code
to
implement
that
feature
using
the
jquery
javascript
library
var
show
next
tip
function
var
num
tips
tip
size
var
shown
tip
tip
visible
var
shown
tip
num
number
shown
tip
attr
id
slice
if
shown
tip
num
num
tips
tip
show
else
tip
shown
tip
num
show
shown
tip
hide
this
code
is
okay
but
it
can
be
made
better
let
s
start
by
describing
in
words
what
this
code
is
trying
to
do
find
the
currently
visible
tip
and
hide
it
then
find
the
next
tip
after
it
and
show
that
if
we
ve
run
out
of
tips
cycle
back
to
the
first
tip
turning
thoughts
into
code
based
on
this
description
here
s
another
solution
var
show
next
tip
function
var
cur
tip
tip
visible
hide
var
next
tip
cur
tip
next
tip
if
next
tip
size
next
tip
tip
first
next
tip
show
find
the
currently
visible
tip
and
hide
it
find
the
next
tip
after
it
if
we
ve
run
out
of
tips
cycle
back
to
the
first
tip
show
the
new
tip
this
solution
contains
fewer
lines
of
code
and
doesn
t
have
to
manipulate
integers
directly
it
s
more
aligned
with
how
a
person
would
think
about
the
code
in
this
case
it
helped
that
jquery
has
a
next
method
we
could
use
part
of
writing
succinct
code
is
being
aware
of
what
your
library
has
to
offer
applying
this
method
to
larger
problems
the
previous
examples
have
applied
our
process
to
small
blocks
of
code
in
the
next
example
we
ll
apply
it
to
a
larger
function
as
you
ll
see
this
method
can
help
you
break
down
your
code
by
helping
you
identify
what
pieces
you
can
break
away
imagine
we
have
a
system
that
records
stock
purchases
each
transaction
has
four
pieces
of
data
time
a
precise
date
and
time
of
the
purchase
ticker
symbol
e
g
goog
price
e
g
number
of
shares
e
g
for
some
strange
reason
the
data
is
spread
across
three
separate
database
tables
as
illustrated
here
in
each
database
the
time
is
the
unique
primary
key
now
we
need
to
write
a
program
to
join
the
three
tables
back
together
as
an
sql
join
operation
would
do
this
step
should
be
easy
because
the
rows
are
all
sorted
by
time
but
unfortunately
some
of
the
rows
are
missing
you
want
to
find
all
the
rows
where
all
three
times
match
up
and
ignore
any
rows
that
can
t
be
lined
up
as
shown
in
the
previous
illustration
chapter
twelve
here
is
some
python
code
that
finds
all
the
matching
rows
def
printstocktransactions
stock
iter
db
read
select
time
ticker
symbol
from
price
iter
num
shares
iter
iterate
through
all
the
rows
of
the
tables
in
parallel
while
stock
iter
and
price
iter
and
num
shares
iter
stock
time
stock
iter
time
price
time
price
iter
time
num
shares
time
num
shares
iter
time
if
all
rows
don
t
have
the
same
time
skip
over
the
oldest
row
note
the
below
can
t
just
be
in
case
there
are
tied
oldest
if
stock
time
price
time
or
stock
time
num
shares
time
if
stock
time
price
time
and
stock
time
num
shares
time
stock
iter
nextrow
elif
price
time
stock
time
and
price
time
num
shares
time
price
iter
nextrow
elif
num
shares
time
stock
time
and
num
shares
time
price
time
num
shares
iter
nextrow
else
assert
false
impossible
continue
assert
stock
time
price
time
num
shares
time
print
the
aligned
rows
print
stock
time
print
stock
iter
ticker
symbol
print
price
iter
price
print
num
shares
iter
number
of
shares
stock
iter
nextrow
price
iter
nextrow
num
shares
iter
nextrow
this
example
code
works
but
there
s
a
lot
going
on
with
how
the
loop
skips
over
unmatched
rows
some
warning
flags
might
have
gone
off
in
your
head
could
this
miss
any
rows
might
it
read
past
the
end
of
stream
for
any
of
the
iterators
so
how
can
we
make
it
more
readable
an
english
description
of
the
solution
once
again
let
s
step
back
and
describe
in
plain
english
what
we
re
trying
to
do
we
are
reading
three
row
iterators
in
parallel
whenever
the
rows
times
don
t
line
up
advance
the
rows
so
they
do
line
up
then
print
the
aligned
rows
and
advance
the
rows
again
keep
doing
this
until
there
are
no
more
matching
rows
left
turning
thoughts
into
code
looking
back
at
the
original
code
the
messiest
part
was
the
block
dealing
with
advance
the
rows
so
they
do
line
up
to
present
the
code
more
clearly
we
can
extract
all
that
messy
logic
into
a
new
function
named
advancetomatchingtime
here
s
a
new
version
of
the
code
making
use
of
this
new
function
def
printstocktransactions
stock
iter
price
iter
num
shares
iter
while
true
time
advancetomatchingtime
stock
iter
price
iter
num
shares
iter
if
time
is
none
return
print
the
aligned
rows
print
time
print
stock
iter
ticker
symbol
print
price
iter
price
print
num
shares
iter
number
of
shares
stock
iter
nextrow
price
iter
nextrow
num
shares
iter
nextrow
as
you
can
see
this
code
is
much
easier
to
understand
as
we
ve
hidden
away
all
the
dirty
details
of
lining
up
the
rows
applying
the
method
recursively
it
s
easy
to
imagine
how
you
would
write
advancetomatchingtime
in
the
worst
case
it
would
look
very
similar
to
that
ugly
block
of
code
from
the
first
version
def
advancetomatchingtime
stock
iter
price
iter
num
shares
iter
iterate
through
all
the
rows
of
the
tables
in
parallel
while
stock
iter
and
price
iter
and
num
shares
iter
stock
time
stock
iter
time
price
time
price
iter
time
num
shares
time
num
shares
iter
time
if
all
rows
don
t
have
the
same
time
skip
over
the
oldest
row
if
stock
time
price
time
or
stock
time
num
shares
time
if
stock
time
price
time
and
stock
time
num
shares
time
stock
iter
nextrow
elif
price
time
stock
time
and
price
time
num
shares
time
price
iter
nextrow
elif
num
shares
time
stock
time
and
num
shares
time
price
time
num
shares
iter
nextrow
else
assert
false
impossible
continue
chapter
twelve
assert
stock
time
price
time
num
shares
time
return
stock
time
but
let
s
improve
that
code
by
applying
our
method
to
advancetomatchingtime
as
well
here
s
a
description
of
what
this
function
needs
to
do
look
at
the
times
of
each
current
row
if
they
re
aligned
we
re
done
otherwise
advance
any
rows
that
are
behind
keep
doing
this
until
the
rows
are
aligned
or
one
of
the
iterators
has
ended
this
description
is
a
lot
clearer
and
more
elegant
than
the
previous
code
one
thing
to
notice
is
that
the
description
never
mentions
stock
iter
or
other
details
specific
to
our
problem
this
means
we
can
also
rename
the
variables
to
be
simpler
and
more
general
here
s
the
resulting
code
def
advancetomatchingtime
row
iter
row
iter
row
iter
while
row
iter
and
row
iter
and
row
iter
t
row
iter
time
t
row
iter
time
t
row
iter
time
if
t
t
t
return
t
tmax
max
t
t
t
if
any
row
is
behind
advance
it
eventually
this
while
loop
will
align
them
all
if
t
tmax
row
iter
nextrow
if
t
tmax
row
iter
nextrow
if
t
tmax
row
iter
nextrow
return
none
no
alignment
could
be
found
as
you
can
see
this
code
is
a
lot
clearer
than
before
the
algorithm
became
simpler
and
now
there
are
fewer
tricky
comparisons
and
we
used
short
names
like
t
and
no
longer
had
to
think
about
the
specific
database
columns
involved
summary
this
chapter
discussed
the
simple
technique
of
describing
your
program
in
plain
english
and
using
that
description
to
help
you
write
more
natural
code
this
technique
is
deceptively
simple
but
very
powerful
looking
at
the
words
and
phrases
used
in
your
description
can
also
help
you
identify
which
subproblems
to
break
off
but
this
process
of
saying
things
in
plain
english
is
applicable
outside
of
just
writing
code
for
example
one
college
computer
lab
policy
states
that
when
a
student
needs
help
debugging
his
program
he
first
has
to
explain
the
problem
to
a
dedicated
teddy
bear
in
the
corner
of
the
room
surprisingly
just
describing
the
problem
aloud
can
often
help
the
student
figure
out
a
solution
this
technique
is
called
rubber
ducking
turning
thoughts
into
code
another
way
to
look
at
it
is
this
if
you
can
t
describe
the
problem
or
your
design
in
words
something
is
probably
missing
or
undefined
getting
a
program
or
any
idea
into
words
can
really
force
it
into
shape
chapter
twelve
chapter
thirteen
writing
less
code
knowing
when
not
to
code
is
possibly
the
most
important
skill
a
programmer
can
learn
every
line
of
code
you
write
is
a
line
that
has
to
be
tested
and
maintained
by
reusing
libraries
or
eliminating
features
you
can
save
time
and
keep
your
codebase
lean
and
mean
key
idea
the
most
readable
code
is
no
code
at
all
don
t
bother
implementing
that
feature
you
won
t
need
it
when
you
start
a
project
it
s
natural
to
get
excited
and
think
of
all
the
cool
features
you
ll
want
to
implement
but
programmers
tend
to
overestimate
how
many
features
are
truly
essential
to
their
project
a
lot
of
features
go
unfinished
or
unused
or
just
complicate
the
application
programmers
also
tend
to
underestimate
how
much
effort
it
takes
to
implement
a
feature
we
optimistically
estimate
how
long
it
will
take
to
implement
a
crude
prototype
but
forget
how
much
extra
time
is
involved
in
future
maintenance
documentation
and
the
added
weight
to
the
codebase
question
and
break
down
your
requirements
not
all
programs
need
to
be
fast
correct
and
able
to
handle
every
possible
input
if
you
really
scrutinize
your
requirements
sometimes
you
can
carve
out
a
simpler
problem
that
requires
less
code
let
s
look
at
some
examples
of
this
example
a
store
locator
suppose
you
were
writing
a
store
locator
for
a
business
you
think
your
requirements
are
for
any
given
user
s
latitude
longitude
find
the
store
with
the
closest
latitude
longitude
to
implement
this
correctly
you
would
need
to
handle
when
the
locations
are
on
either
side
of
the
international
date
line
when
the
locations
are
near
the
north
or
south
pole
adjusting
for
the
curvature
of
the
earth
as
longitudinal
degrees
per
mile
changes
handling
all
of
these
cases
requires
a
fair
amount
of
code
for
your
application
however
there
are
only
stores
in
the
state
of
texas
in
this
smaller
region
the
three
issues
in
the
list
aren
t
that
important
as
a
result
you
can
reduce
your
requirements
to
for
a
user
near
texas
find
approximately
the
closest
store
in
texas
chapter
thirteen
solving
this
problem
is
easier
as
you
can
get
away
with
just
iterating
through
each
store
and
computing
the
euclidean
distance
between
the
latitudes
longitudes
example
adding
a
cache
we
once
had
a
java
application
that
frequently
read
objects
from
disk
the
speed
of
the
application
was
limited
by
these
reads
so
we
wanted
to
implement
caching
of
some
sort
a
typical
sequence
of
reads
looked
like
this
read
read
read
read
read
read
read
read
object
object
object
object
object
object
object
object
a
a
a
b
b
c
d
d
as
you
can
see
there
were
a
lot
of
repeated
accesses
to
the
same
object
so
caching
should
definitely
have
helped
when
faced
with
this
problem
our
first
instinct
was
to
use
a
cache
that
discards
the
least
recently
used
items
we
didn
t
have
one
available
in
our
library
so
we
would
have
had
to
implement
it
ourselves
that
wasn
t
a
problem
though
as
we
ve
implemented
such
a
data
structure
before
it
involves
both
a
hash
table
and
a
singly
linked
list
perhaps
lines
of
code
in
total
however
we
noticed
that
the
repeated
accesses
were
always
in
a
row
so
instead
of
implementing
an
lru
cache
we
just
implemented
a
one
item
cache
diskobject
lastused
class
member
diskobject
lookup
string
key
if
lastused
null
lastused
key
equals
key
lastused
loaddiskobject
key
return
lastused
this
got
us
of
the
benefit
without
much
coding
and
the
program
had
a
small
memory
footprint
too
the
benefits
of
removing
requirements
and
solving
simpler
problems
can
t
be
overstated
requirements
often
interfere
with
each
other
in
subtle
ways
this
means
that
solving
half
the
problem
might
only
take
a
quarter
as
much
coding
effort
writing
less
code
keeping
your
codebase
small
when
you
first
start
a
software
project
and
you
have
only
one
or
two
source
files
things
are
great
compiling
and
running
the
code
is
a
snap
it
s
easy
to
make
changes
and
it
s
easy
to
remember
where
each
function
or
class
is
defined
then
as
the
project
grows
your
directory
fills
up
with
more
and
more
source
files
soon
you
need
multiple
directories
to
organize
them
all
it
s
harder
to
remember
which
functions
call
which
other
functions
and
tracking
down
bugs
takes
a
little
more
work
eventually
you
have
lots
of
source
code
spread
across
many
different
directories
the
project
is
huge
and
no
single
person
understands
it
all
adding
new
features
becomes
painful
and
working
with
the
code
is
cumbersome
and
unpleasant
what
we
ve
described
is
a
natural
law
of
the
universe
as
any
coordinated
system
grows
the
complexity
needed
to
keep
it
glued
together
grows
even
faster
the
best
way
to
cope
is
to
keep
your
codebase
as
small
and
lightweight
as
possible
even
as
your
project
grows
thus
you
should
create
as
much
generic
utility
code
as
possible
to
remove
duplicated
code
see
chapter
extracting
unrelated
subproblems
remove
unused
code
or
useless
features
see
the
following
sidebar
keep
your
project
compartmentalized
into
disconnected
subprojects
generally
be
conscious
of
the
weight
of
your
codebase
keep
it
light
and
nimble
chapter
thirteen
removing
unused
code
gardeners
often
prune
plants
to
keep
them
alive
and
growing
similarly
it
s
a
good
idea
to
prune
any
unused
code
that
s
getting
in
the
way
once
code
is
written
coders
are
often
reluctant
to
delete
it
because
it
represents
a
lot
of
real
work
to
delete
it
would
mean
admitting
that
the
time
spent
on
it
was
wasted
well
get
over
it
this
is
a
creative
field
photographers
writers
and
filmmakers
don
t
keep
all
of
their
work
either
deleting
isolated
functions
is
easy
but
sometimes
unused
code
is
actually
woven
throughout
your
project
unbeknownst
to
you
here
are
some
examples
you
originally
designed
your
system
to
handle
international
filenames
and
now
the
code
is
littered
with
conversion
code
however
that
code
isn
t
fully
functional
and
your
app
is
never
used
with
international
filenames
anyhow
why
not
remove
this
functionality
you
wanted
your
program
to
work
even
if
the
system
ran
out
of
memory
so
you
have
lots
of
clever
logic
that
tries
to
recover
from
out
of
memory
situations
it
was
a
good
idea
but
in
practice
when
the
system
runs
out
of
memory
your
program
just
becomes
an
unstable
zombie
anyway
all
the
core
features
are
unusable
and
it
s
one
mouse
click
away
from
dying
why
not
just
terminate
the
program
with
a
simple
the
system
is
out
of
memory
sorry
and
remove
all
this
out
of
memory
code
be
familiar
with
the
libraries
around
you
a
lot
of
the
time
programmers
just
aren
t
aware
that
existing
libraries
can
solve
their
problem
or
sometimes
they
ve
forgotten
what
a
library
can
do
it
s
important
to
know
the
capabilities
of
your
library
code
so
that
you
can
make
use
of
it
here
s
a
modest
suggestion
every
once
in
a
while
spend
minutes
reading
the
names
of
all
the
functions
modules
types
in
your
standard
library
these
include
the
c
standard
template
library
stl
the
java
api
the
built
in
python
modules
and
others
the
goal
isn
t
to
memorize
the
whole
library
it
s
just
to
get
a
sense
of
what
s
available
so
that
next
time
you
re
working
on
new
code
you
ll
think
wait
this
sounds
similar
to
something
i
saw
in
the
api
we
believe
doing
this
work
upfront
pays
off
quickly
as
you
ll
be
more
inclined
to
use
those
libraries
in
the
first
place
writing
less
code
example
lists
and
sets
in
python
suppose
you
have
a
list
in
python
like
and
you
want
a
list
of
the
unique
elements
in
this
case
you
could
implement
this
task
using
a
dictionary
which
has
a
list
of
keys
that
are
guaranteed
to
be
unique
def
unique
elements
temp
for
element
in
elements
temp
element
none
return
temp
keys
the
value
doesn
t
matter
unique
elements
unique
but
instead
you
can
just
use
the
lesser
known
set
type
unique
elements
set
remove
duplicates
this
object
is
iterable
just
like
a
normal
list
if
you
really
want
a
list
object
again
you
can
just
use
unique
elements
list
set
remove
duplicates
clearly
set
is
the
right
tool
for
the
job
here
but
if
you
weren
t
aware
of
the
set
type
you
might
produce
code
like
unique
above
why
reusing
libraries
is
such
a
win
a
commonly
cited
statistic
is
that
the
average
software
engineer
produces
ten
shippable
lines
of
code
a
day
when
programmers
first
hear
this
they
balk
in
disbelief
ten
lines
of
code
i
can
write
that
in
a
minute
the
key
word
is
shippable
each
line
of
code
in
a
mature
library
represents
a
fair
amount
of
design
debugging
rewriting
documenting
optimizing
and
testing
any
line
of
code
that
s
survived
this
darwinian
process
is
very
valuable
this
is
why
reusing
libraries
is
such
a
win
in
both
saving
time
and
having
less
code
to
write
example
using
unix
tools
instead
of
coding
when
a
web
server
frequently
returns
xx
or
xx
http
response
codes
it
s
a
sign
of
a
potential
problem
xx
being
a
client
error
xx
being
a
server
error
so
we
wanted
to
write
a
program
that
parses
a
web
server
s
access
logs
and
determines
which
urls
are
causing
the
most
errors
the
access
logs
typically
look
something
like
this
example
com
aug
get
index
html
http
example
com
aug
get
help
topic
http
example
com
aug
get
favicon
ico
http
generally
they
contain
lines
of
this
form
chapter
thirteen
browser
ip
host
date
get
url
path
http
http
response
code
writing
a
program
to
find
the
most
common
url
paths
with
xx
or
xx
response
codes
might
easily
take
lines
of
code
in
a
language
like
c
or
java
instead
in
unix
you
can
type
this
command
line
cat
access
log
awk
print
egrep
sort
uniq
c
sort
nr
which
produces
output
like
this
favicon
ico
help
topic
login
count
path
http
response
code
what
s
great
about
this
command
line
is
that
we
ve
avoided
writing
any
real
code
or
checking
anything
into
source
control
summary
adventure
excitement
a
jedi
craves
not
these
things
yoda
this
chapter
is
about
writing
as
little
new
code
as
possible
each
new
line
of
code
needs
to
be
tested
documented
and
maintained
further
the
more
code
in
your
codebase
the
heavier
it
gets
and
the
harder
it
is
to
develop
in
you
can
avoid
writing
new
lines
of
code
by
eliminating
nonessential
features
from
your
product
and
not
overengineering
rethinking
requirements
to
solve
the
easiest
version
of
the
problem
that
still
gets
the
job
done
staying
familiar
with
standard
libraries
by
periodically
reading
through
their
entire
apis
writing
less
code
part
iv
selected
topics
in
the
previous
three
parts
we
covered
a
wide
range
of
techniques
for
making
code
easy
to
understand
in
this
part
we
re
going
to
apply
some
of
these
techniques
to
two
selected
topics
first
we
re
going
to
discuss
testing
how
to
write
tests
that
are
effective
and
readable
at
the
same
time
then
we
re
going
to
walk
through
the
design
and
implementation
of
a
special
purpose
data
structure
a
minute
hour
counter
to
see
an
example
where
performance
good
design
and
readability
interplay
chapter
fourteen
testing
and
readability
in
this
chapter
we
re
going
to
show
you
simple
techniques
to
write
neat
and
effective
tests
testing
means
different
things
to
different
people
in
this
chapter
we
use
test
to
mean
any
code
whose
sole
purpose
is
to
check
the
behavior
of
another
real
piece
of
code
we
re
going
to
focus
on
the
readability
aspect
of
tests
and
not
get
into
whether
you
should
write
test
code
before
writing
real
code
test
driven
development
or
other
philosophical
aspects
of
test
development
make
tests
easy
to
read
and
maintain
it
s
just
as
important
for
test
code
to
be
readable
as
it
is
for
nontest
code
other
coders
will
often
look
at
the
test
code
as
unofficial
documentation
of
how
the
real
code
works
and
should
be
used
so
if
the
tests
are
easy
to
read
users
will
better
understand
how
the
real
code
behaves
key
idea
test
code
should
be
readable
so
that
other
coders
are
comfortable
changing
or
adding
tests
when
test
code
is
big
and
scary
here
s
what
happens
coders
are
afraid
to
modify
the
real
code
oh
we
don
t
want
to
mess
with
that
code
updating
all
the
tests
would
be
a
nightmare
coders
don
t
add
new
tests
when
they
add
new
code
over
time
less
and
less
of
your
module
is
tested
and
you
are
no
longer
confident
that
it
all
works
instead
you
want
to
encourage
users
of
your
code
especially
you
to
be
comfortable
with
the
test
code
they
should
be
able
to
diagnose
why
a
new
change
is
breaking
an
existing
test
and
feel
like
adding
new
tests
is
easy
what
s
wrong
with
this
test
in
our
codebase
we
had
a
function
to
sort
and
filter
a
list
of
scored
search
results
here
s
the
function
declaration
sort
docs
by
score
highest
first
and
remove
negative
scored
documents
void
sortandfilterdocs
vector
scoreddocument
docs
the
test
for
this
function
originally
looked
something
like
void
test
vector
scoreddocument
docs
docs
resize
docs
url
http
example
com
docs
score
docs
url
http
example
com
docs
score
chapter
fourteen
docs
url
docs
score
docs
url
docs
score
docs
url
docs
score
http
example
com
http
example
com
http
example
com
sortandfilterdocs
docs
assert
docs
size
assert
docs
score
assert
docs
score
assert
docs
score
there
are
at
least
eight
different
problems
with
this
test
code
by
the
end
of
the
chapter
you
ll
be
able
to
identify
and
fix
all
of
them
making
this
test
more
readable
as
a
general
design
principle
you
should
hide
less
important
details
from
the
user
so
that
more
important
details
are
most
prominent
the
test
code
from
the
previous
section
clearly
violates
this
principle
every
detail
of
the
test
is
front
and
center
like
the
unimportant
minutiae
of
setting
up
a
vector
scoreddocument
most
of
the
example
code
involves
url
score
and
docs
which
are
just
details
about
how
the
underlying
c
objects
are
set
up
not
about
what
this
test
is
doing
at
a
high
level
as
a
first
step
in
cleaning
this
up
we
could
create
a
helper
function
like
void
makescoreddoc
scoreddocument
sd
double
score
string
url
sd
score
score
sd
url
url
using
this
function
our
test
code
becomes
slightly
more
compact
void
test
vector
scoreddocument
docs
docs
resize
makescoreddoc
docs
http
example
com
makescoreddoc
docs
http
example
com
makescoreddoc
docs
http
example
com
makescoreddoc
docs
http
example
com
but
this
isn
t
good
enough
there
are
still
unimportant
details
in
our
face
for
instance
the
parameter
http
example
com
is
just
an
eyesore
it
s
always
the
same
and
the
exact
url
doesn
t
even
matter
it
s
just
needed
to
fill
out
a
valid
scoreddocument
testing
and
readability
another
unimportant
detail
we
re
forced
to
see
is
docs
resize
and
docs
docs
and
so
on
let
s
change
our
helper
function
to
do
more
work
for
us
and
call
it
addscoreddoc
void
addscoreddoc
vector
scoreddocument
docs
double
score
scoreddocument
sd
sd
score
score
sd
url
http
example
com
docs
push
back
sd
using
this
function
our
test
code
is
even
more
compact
void
test
vector
scoreddocument
docs
addscoreddoc
docs
addscoreddoc
docs
addscoreddoc
docs
addscoreddoc
docs
this
code
is
better
but
still
doesn
t
pass
the
highly
readable
and
writable
test
if
you
wanted
to
add
another
test
with
a
new
set
of
scored
docs
it
would
require
a
lot
of
copying
and
pasting
so
how
do
we
go
about
improving
it
further
creating
the
minimal
test
statement
to
improve
this
test
code
let
s
use
the
technique
from
chapter
turning
thoughts
into
code
let
s
describe
what
our
test
is
trying
to
do
in
plain
english
we
have
a
list
of
documents
whose
scores
are
after
sortandfilterdocs
the
remaining
documents
should
have
scores
of
in
that
order
as
you
can
see
nowhere
in
that
description
did
we
mention
a
vector
scoreddocument
the
array
of
scores
is
what
s
most
important
here
ideally
our
test
code
would
look
something
like
checkscoresbeforeafter
we
were
able
to
boil
the
essence
of
this
test
down
to
one
line
of
code
this
is
not
uncommon
though
the
essence
of
most
tests
boils
down
to
for
this
input
situation
expect
this
behavior
output
and
many
times
this
goal
can
be
expressed
in
just
one
line
in
addition
to
making
the
code
very
compact
and
readable
keeping
your
test
statements
short
makes
it
very
easy
to
add
more
test
cases
implementing
custom
minilanguages
notice
that
checkscoresbeforeafter
takes
two
string
arguments
that
describe
the
array
of
scores
in
later
versions
of
c
you
can
pass
in
array
literals
like
this
checkscoresbeforeafter
chapter
fourteen
because
we
couldn
t
do
this
at
the
time
we
put
the
scores
inside
a
string
separated
by
commas
for
this
approach
to
work
checkscoresbeforeafter
is
going
to
have
to
parse
those
string
arguments
in
general
defining
a
custom
minilanguage
can
be
a
powerful
way
to
express
a
lot
of
information
in
a
small
amount
of
space
other
examples
include
printf
and
regular
expression
libraries
in
this
case
writing
some
helper
functions
to
parse
a
comma
separated
list
of
numbers
shouldn
t
be
too
hard
here
s
what
checkscoresbeforeafter
would
look
like
void
checkscoresbeforeafter
string
input
string
expected
output
vector
scoreddocument
docs
scoreddocsfromstring
input
sortandfilterdocs
docs
string
output
scoreddocstostring
docs
assert
output
expected
output
and
for
completeness
here
are
the
helper
functions
that
convert
between
string
and
vector
scoreddocument
vector
scoreddocument
scoreddocsfromstring
string
scores
vector
scoreddocument
docs
replace
scores
begin
scores
end
populate
docs
from
a
string
of
space
separated
scores
istringstream
stream
scores
double
score
while
stream
score
addscoreddoc
docs
score
return
docs
string
scoreddocstostring
vector
scoreddocument
docs
ostringstream
stream
for
int
i
i
docs
size
i
if
i
stream
stream
docs
i
score
return
stream
str
this
may
seem
like
a
lot
of
code
at
first
glance
but
what
it
lets
you
do
is
incredibly
powerful
because
you
can
write
an
entire
test
with
just
one
call
to
checkscoresbeforeafter
you
ll
be
inclined
to
add
more
tests
as
we
ll
be
doing
later
in
the
chapter
testing
and
readability
making
error
messages
readable
the
preceding
code
was
nice
but
what
happens
when
that
assert
output
expected
output
line
fails
it
produces
an
error
message
like
this
assertion
failed
output
expected
output
function
checkscoresbeforeafter
file
test
cc
line
obviously
if
you
ever
saw
this
error
you
d
wonder
what
were
the
values
of
output
and
expected
output
using
better
versions
of
assert
fortunately
most
languages
and
libraries
have
more
sophisticated
versions
of
assert
you
can
use
so
instead
of
writing
assert
output
expected
output
you
could
use
the
boost
c
library
boost
require
equal
output
expected
output
now
if
the
test
fails
you
get
a
more
detailed
message
like
test
cc
fatal
error
in
checkscoresbeforeafter
critical
check
output
expected
output
failed
which
is
much
more
helpful
chapter
fourteen
you
should
use
these
more
helpful
assertion
methods
when
they
re
available
it
ll
pay
off
every
time
your
test
fails
better
assert
in
other
languages
in
python
the
built
in
statement
assert
a
b
produces
a
plain
error
message
like
file
file
py
line
x
in
module
assert
a
b
assertionerror
instead
you
can
use
the
assertequal
method
in
the
unittest
module
import
unittest
class
mytestcase
unittest
testcase
def
testfunction
self
a
b
self
assertequal
a
b
if
name
main
unittest
main
which
produces
an
error
message
like
file
mytestcase
py
line
in
testfunction
self
assertequal
a
b
assertionerror
whichever
language
you
re
using
there
s
probably
a
library
framework
e
g
xunit
available
to
help
you
it
pays
to
know
your
libraries
hand
crafted
error
messages
using
boost
require
equal
we
were
able
to
get
the
nicer
error
message
output
expected
output
failed
however
this
message
could
be
improved
further
for
instance
it
would
be
useful
to
see
the
original
input
that
triggered
this
failure
the
ideal
error
message
would
be
something
like
checkscoresbeforeafter
failed
input
expected
output
actual
output
if
this
is
what
you
want
go
ahead
and
write
it
testing
and
readability
void
checkscoresbeforeafter
if
output
expected
output
cerr
checkscoresbeforeafter
failed
endl
cerr
input
input
endl
cerr
expected
output
expected
output
endl
cerr
actual
output
output
endl
abort
the
moral
of
the
story
is
that
error
messages
should
be
as
helpful
as
possible
sometimes
printing
your
own
message
by
building
a
custom
assert
is
the
best
way
to
do
this
choosing
good
test
inputs
there
s
an
art
to
choosing
good
input
values
for
your
tests
the
ones
we
have
right
now
seem
a
bit
haphazard
checkscoresbeforeafter
how
do
we
choose
good
input
values
good
inputs
should
thoroughly
test
the
code
but
they
should
also
be
simple
so
that
they
re
easy
to
read
key
idea
in
general
you
should
pick
the
simplest
set
of
inputs
that
completely
exercise
the
code
for
example
suppose
we
had
just
written
checkscoresbeforeafter
although
this
test
is
simple
it
doesn
t
test
the
filter
negative
scores
behavior
of
sortandfilterdocs
if
there
were
a
bug
in
that
part
of
the
code
this
input
wouldn
t
trigger
it
on
the
other
extreme
suppose
we
wrote
our
test
like
this
checkscoresbeforeafter
these
values
are
needlessly
complex
and
they
don
t
even
test
the
code
thoroughly
simplifying
the
input
values
so
what
can
we
do
to
improve
these
input
values
checkscoresbeforeafter
chapter
fourteen
well
the
first
thing
you
probably
noticed
is
the
very
loud
value
that
value
was
just
meant
to
be
any
negative
number
so
a
simpler
value
is
just
if
was
meant
to
be
a
very
negative
number
a
better
value
would
have
been
something
crisp
like
e
key
idea
prefer
clean
and
simple
test
values
that
still
get
the
job
done
the
other
values
in
our
test
aren
t
too
bad
but
while
we
re
here
we
can
reduce
them
to
the
simplest
integers
possible
also
only
one
negative
value
is
needed
to
test
that
negative
values
are
removed
here
s
a
new
version
of
our
test
checkscoresbeforeafter
we
ve
simplified
the
test
values
without
making
them
any
less
effective
large
smasher
tests
there
is
definitely
value
in
testing
your
code
against
large
crazy
inputs
for
instance
you
might
be
tempted
to
include
a
test
like
checkscoresbeforeafter
lots
of
values
large
inputs
like
these
do
a
good
job
of
exposing
bugs
such
as
buffer
overruns
or
others
you
might
not
expect
but
code
like
this
is
big
and
scary
to
look
at
and
not
completely
effective
in
stress
testing
the
code
instead
it
s
more
effective
to
construct
large
inputs
programmatically
constructing
a
large
input
of
say
values
testing
and
readability
multiple
tests
of
functionality
rather
than
construct
a
single
perfect
input
to
thoroughly
exercise
your
code
it
s
often
easier
more
effective
and
more
readable
to
write
multiple
smaller
tests
each
test
should
push
your
code
in
a
certain
direction
trying
to
find
a
particular
bug
for
example
here
are
four
tests
for
sortandfilterdocs
checkscoresbeforeafter
checkscoresbeforeafter
checkscoresbeforeafter
checkscoresbeforeafter
basic
sorting
all
values
removed
duplicates
not
a
problem
empty
input
ok
there
are
even
more
tests
you
could
write
if
you
wanted
to
be
extremely
thorough
having
separate
test
cases
also
makes
it
easier
for
the
next
person
working
on
the
code
if
someone
accidentally
introduces
a
bug
the
test
failure
will
pinpoint
the
specific
test
that
failed
naming
test
functions
test
code
is
typically
organized
into
functions
one
for
each
method
and
or
situation
you
re
testing
for
instance
the
code
testing
sortandfilterdocs
was
inside
a
function
named
test
void
test
picking
a
good
name
for
a
test
function
can
seem
tedious
and
irrelevant
but
don
t
resort
to
meaningless
names
like
test
test
and
the
like
instead
you
should
use
the
name
to
describe
details
about
the
test
in
particular
it
s
handy
if
the
person
reading
the
test
code
can
quickly
figure
out
the
class
being
tested
if
any
the
function
being
tested
the
situation
or
bug
being
tested
a
simple
approach
to
construct
a
good
test
function
name
is
to
just
concatenate
that
information
together
possibly
with
a
test
prefix
for
instance
instead
of
naming
it
test
we
can
use
the
test
functionname
format
void
test
sortandfilterdocs
depending
on
how
sophisticated
this
test
is
you
might
consider
a
separate
test
function
for
each
situation
being
tested
you
could
use
the
test
functionname
situation
format
void
test
sortandfilterdocs
basicsorting
chapter
fourteen
void
test
sortandfilterdocs
negativevalues
don
t
be
afraid
of
having
a
long
or
clunky
name
here
this
isn
t
a
function
that
will
be
called
throughout
your
codebase
so
the
reasons
for
avoiding
long
function
names
don
t
apply
the
test
function
name
is
effectively
acting
like
a
comment
also
if
that
test
fails
most
testing
frameworks
will
print
out
the
name
of
the
function
where
the
assertion
failed
so
a
descriptive
name
is
especially
helpful
note
that
if
you
re
using
a
testing
framework
there
might
already
be
rules
or
conventions
on
how
methods
are
named
for
instance
the
python
unittest
module
expects
test
method
names
to
start
with
test
when
it
comes
to
naming
helper
functions
in
your
test
code
it
s
useful
to
highlight
whether
the
function
does
any
assertions
itself
or
is
just
an
ordinary
test
unaware
helper
for
instance
in
this
chapter
any
helper
function
that
calls
assert
is
named
check
but
the
function
addscoreddoc
was
named
just
like
an
ordinary
helper
function
what
was
wrong
with
that
test
at
the
beginning
of
the
chapter
we
claimed
there
were
at
least
eight
things
wrong
with
this
test
void
test
vector
scoreddocument
docs
docs
resize
docs
url
http
example
com
docs
score
docs
url
http
example
com
docs
score
docs
url
http
example
com
docs
score
docs
url
http
example
com
docs
score
docs
url
http
example
com
docs
score
sortandfilterdocs
docs
assert
docs
size
assert
docs
score
assert
docs
score
assert
docs
score
now
that
we
ve
learned
some
techniques
for
writing
better
tests
let
s
identify
them
testing
and
readability
the
test
is
very
long
and
full
of
unimportant
details
you
can
describe
what
this
test
is
doing
in
one
sentence
so
the
test
statement
shouldn
t
be
much
longer
adding
another
test
isn
t
easy
you
d
be
tempted
to
copy
paste
modify
which
would
make
the
code
even
longer
and
full
of
duplication
the
test
failure
messages
aren
t
very
useful
if
this
test
fails
it
will
just
say
assertion
failed
docs
size
which
doesn
t
give
you
enough
information
to
debug
it
further
the
test
tries
to
test
everything
at
once
it
s
trying
to
test
both
the
negative
filtering
and
the
sorting
functionality
it
would
be
more
readable
to
break
this
into
multiple
tests
the
test
inputs
aren
t
simple
in
particular
the
example
score
is
loud
and
gets
your
attention
even
though
there
isn
t
any
significance
to
that
specific
value
a
simpler
negative
value
would
suffice
the
test
inputs
don
t
thoroughly
exercise
the
code
for
example
it
doesn
t
test
when
the
score
is
would
that
document
be
filtered
or
not
it
doesn
t
test
other
extreme
inputs
such
as
an
empty
input
vector
a
very
large
vector
or
one
with
duplicate
scores
the
name
test
is
meaningless
the
name
should
describe
the
function
or
situation
being
tested
test
friendly
development
some
code
is
easier
to
test
than
other
code
ideal
code
to
test
has
a
well
defined
interface
doesn
t
have
much
state
or
other
setup
and
doesn
t
have
much
hidden
data
to
inspect
if
you
write
your
code
knowing
you
ll
be
writing
a
test
for
it
later
a
funny
thing
happens
you
start
designing
your
code
so
that
it
s
easy
to
test
fortunately
coding
this
way
also
means
that
you
create
better
code
in
general
test
friendly
designs
often
lead
naturally
to
wellorganized
code
with
separate
parts
to
do
separate
things
test
driven
development
test
driven
development
tdd
is
a
programming
style
where
you
write
the
tests
before
you
write
the
real
code
tdd
proponents
believe
this
process
profoundly
improves
the
quality
of
the
nontest
code
much
more
so
than
if
you
write
the
tests
after
writing
the
code
this
is
a
hotly
debated
topic
that
we
won
t
get
into
at
the
very
least
we
ve
found
that
just
keeping
testing
in
mind
while
writing
code
helps
make
the
code
better
but
regardless
of
whether
you
employ
tdd
the
end
result
is
that
you
have
code
that
tests
other
code
the
goal
of
this
chapter
is
to
help
you
make
your
tests
easier
to
read
and
write
chapter
fourteen
of
all
the
ways
to
break
up
a
program
into
classes
and
methods
the
most
decoupled
ones
are
usually
the
easiest
to
test
on
the
other
hand
let
s
say
your
program
is
very
interconnected
with
many
method
calls
between
your
classes
and
lots
of
parameters
for
all
the
methods
not
only
would
that
program
have
hard
to
understand
code
but
the
test
code
would
be
just
as
ugly
and
hard
to
read
and
write
having
lots
of
external
components
global
variables
that
need
to
be
initialized
libraries
or
config
files
that
need
to
be
loaded
etc
also
makes
it
more
annoying
to
write
tests
generally
if
you
re
designing
your
code
and
realize
hmm
this
is
going
to
be
a
nightmare
to
test
that
s
a
good
reason
to
stop
and
rethink
the
design
table
shows
some
typical
testing
and
design
problems
table
characteristics
of
less
testable
code
and
how
this
leads
to
problems
with
design
characteristic
testability
problem
design
problem
use
of
global
variables
all
the
global
state
needs
to
reset
for
every
test
otherwise
different
tests
can
interfere
with
each
other
hard
to
understand
which
functions
have
what
side
effects
can
t
think
about
each
function
in
isolation
need
to
consider
the
whole
program
to
understand
if
everything
works
code
depends
on
a
lot
of
external
components
it
s
harder
to
write
any
tests
because
there
s
so
much
scaffolding
to
set
up
first
tests
are
less
fun
to
write
so
people
avoid
writing
tests
system
is
more
likely
to
fail
when
one
of
the
dependencies
fails
it
s
harder
to
understand
what
impact
any
given
change
might
make
it
s
harder
to
refactor
classes
system
has
more
failure
modes
and
recovery
paths
to
think
about
code
has
nondeterministic
behavior
tests
are
flaky
and
unreliable
tests
that
occasionally
fail
end
up
being
ignored
the
program
is
more
likely
to
have
race
conditions
or
other
nonreproducible
bugs
the
program
is
harder
to
reason
about
bugs
in
production
are
very
difficult
to
track
down
and
fix
on
the
other
hand
if
you
have
a
design
that
s
easy
to
write
tests
for
that
s
a
good
sign
table
lists
some
beneficial
testing
and
design
characteristics
table
characteristics
of
more
testable
code
and
how
this
leads
to
good
design
characteristic
testability
benefit
design
benefit
classes
have
little
or
no
internal
state
tests
are
easier
to
write
because
there
is
less
setup
needed
to
test
a
method
and
less
hidden
state
to
inspect
classes
with
less
state
are
simpler
and
easier
to
understand
classes
functions
only
do
one
thing
fewer
test
cases
are
required
to
fully
test
it
smaller
simpler
components
are
more
modular
and
the
system
is
generally
more
decoupled
testing
and
readability
classes
depend
on
few
other
classes
high
decoupling
each
class
can
be
tested
independently
much
easier
than
testing
multiple
classes
at
once
system
can
be
developed
in
parallel
classes
can
be
easily
modified
or
removed
without
disrupting
the
rest
of
the
system
functions
have
simple
well
defined
interfaces
there
are
well
defined
behaviors
to
test
for
simple
interfaces
take
less
work
to
test
interfaces
are
easier
for
coders
to
learn
and
are
more
likely
to
be
reused
going
too
far
it
s
also
possible
to
focus
too
much
on
testing
here
are
some
examples
sacrificing
the
readability
of
your
real
code
for
the
sake
of
enabling
tests
designing
your
real
code
to
be
testable
should
be
a
win
win
situation
your
real
code
becomes
simpler
and
more
decoupled
and
your
tests
are
easy
to
write
but
if
you
have
to
insert
lots
of
ugly
plumbing
into
your
real
code
just
so
you
can
test
it
something
s
wrong
being
obsessive
about
test
coverage
testing
the
first
of
your
code
is
often
less
work
than
testing
that
last
that
last
might
involve
user
interface
or
dumb
error
cases
where
the
cost
of
the
bug
isn
t
really
that
high
and
the
effort
to
test
it
just
isn
t
worth
it
the
truth
is
that
you
ll
never
get
coverage
anyhow
if
it
s
not
a
missed
bug
it
might
be
a
missed
feature
or
you
might
not
realize
that
the
spec
should
be
changed
depending
on
how
costly
your
bugs
are
there
s
a
sweet
spot
of
how
much
development
time
it
s
worth
spending
on
test
code
if
you
re
building
a
website
prototype
it
might
not
be
worth
writing
any
test
code
at
all
on
the
other
hand
if
you
re
writing
a
controller
for
a
spaceship
or
medical
device
testing
is
probably
your
main
focus
letting
testing
get
in
the
way
of
product
development
we
ve
seen
situations
where
testing
which
should
be
just
one
aspect
of
a
project
dominates
the
whole
project
testing
becomes
some
sort
of
god
to
be
appeased
and
coders
just
go
through
the
rituals
and
motions
without
realizing
that
their
precious
engineering
time
might
be
better
spent
elsewhere
summary
in
test
code
readability
is
still
very
important
if
your
tests
are
very
readable
they
will
in
turn
be
very
writable
so
people
will
add
more
of
them
also
if
you
design
your
real
code
to
be
easy
to
test
your
code
will
have
a
better
design
overall
here
are
specific
points
on
how
to
improve
your
tests
the
top
level
of
each
test
should
be
as
concise
as
possible
ideally
each
test
input
output
can
be
described
in
one
line
of
code
chapter
fourteen
if
your
test
fails
it
should
emit
an
error
message
that
makes
the
bug
easy
to
track
down
and
fix
use
the
simplest
test
inputs
that
completely
exercise
your
code
give
your
test
functions
a
fully
descriptive
name
so
it
s
clear
what
each
is
testing
instead
of
test
use
a
name
like
test
functionname
situation
and
above
all
make
it
easy
to
modify
and
add
new
tests
testing
and
readability
chapter
fifteen
designing
and
implementing
a
minute
hour
counter
let
s
take
a
look
at
a
data
structure
used
in
real
production
code
a
minute
hour
counter
we
ll
take
you
through
the
natural
thought
process
an
engineer
might
go
through
first
trying
to
solve
this
problem
and
then
improving
its
performance
and
adding
features
most
important
we
ll
also
be
trying
to
keep
the
code
easy
to
read
using
principles
from
throughout
this
book
we
might
take
some
wrong
turns
along
the
way
or
make
other
mistakes
see
if
you
can
follow
along
and
catch
them
the
problem
we
need
to
keep
track
of
how
many
bytes
a
web
server
has
transferred
over
the
past
minute
and
over
the
past
hour
here
s
an
illustration
of
how
these
totals
are
maintained
it
s
a
fairly
straightforward
problem
but
as
you
ll
see
solving
it
efficiently
is
an
interesting
challenge
let
s
start
by
defining
the
class
interface
defining
the
class
interface
here
is
our
first
version
of
the
class
interface
in
c
class
minutehourcounter
public
add
a
count
void
count
int
num
bytes
return
the
count
over
this
minute
int
minutecount
return
the
count
over
this
hour
int
hourcount
before
we
implement
this
class
let
s
go
through
the
names
and
comments
to
see
if
there
s
anything
we
want
to
change
chapter
fifteen
improving
the
names
the
class
name
minutehourcounter
is
pretty
good
it
s
very
specific
concrete
and
easy
to
say
given
the
class
name
the
method
names
minutecount
and
hourcount
are
also
reasonable
you
might
have
called
them
getminutecount
and
gethourcount
but
this
doesn
t
help
anything
as
we
said
in
chapter
names
that
can
t
be
misconstrued
get
implies
lightweight
accessor
to
many
people
and
as
you
ll
see
the
implementation
won
t
be
lightweight
so
it
s
best
to
leave
get
out
the
method
name
count
is
problematic
though
we
asked
our
coworkers
what
they
thought
count
would
do
and
some
thought
it
meant
return
the
total
number
of
counts
over
all
time
the
name
is
a
bit
counterintuitive
no
pun
intended
the
problem
is
that
count
is
both
a
noun
and
a
verb
and
could
mean
either
i
want
a
count
of
the
number
of
samples
you
have
seen
or
i
want
you
to
count
this
sample
here
are
alternative
names
to
consider
in
place
of
count
increment
observe
record
add
increment
is
misleading
because
it
implies
that
there
s
a
value
that
only
increases
in
our
case
the
hour
count
fluctuates
over
time
observe
is
okay
but
a
little
vague
record
also
has
the
noun
verb
problem
so
that
s
no
good
add
is
interesting
because
it
can
either
mean
add
this
numerically
or
add
to
a
list
of
data
in
our
case
it
s
a
little
of
both
so
that
works
so
we
ll
rename
the
method
to
void
add
int
num
bytes
but
the
argument
name
num
bytes
is
too
specific
yes
our
primary
use
case
is
for
counting
bytes
but
minutehourcounter
doesn
t
need
to
know
this
someone
else
might
use
this
class
to
count
queries
or
database
transactions
we
could
use
a
more
generic
name
like
delta
but
the
term
delta
is
often
used
in
places
where
the
value
can
be
negative
which
we
don
t
want
the
name
count
should
work
it
s
simple
generic
and
implies
nonnegative
also
it
lets
us
sneak
in
the
word
count
in
a
less
ambiguous
context
improving
the
comments
here
s
the
class
interface
we
have
so
far
class
minutehourcounter
public
designing
and
implementing
a
minute
hour
counter
add
a
count
void
add
int
count
return
the
count
over
this
minute
int
minutecount
return
the
count
over
this
hour
int
hourcount
let
s
go
through
each
of
these
method
comments
and
improve
them
consider
the
first
one
add
a
count
void
add
int
count
this
comment
is
completely
redundant
now
it
should
be
either
removed
or
improved
here
s
an
improved
version
add
a
new
data
point
count
for
the
next
minute
minutecount
will
be
larger
by
count
for
the
next
hour
hourcount
will
be
larger
by
count
void
add
int
count
now
let
s
consider
the
comment
for
minutecount
return
the
count
over
this
minute
int
minutecount
when
we
asked
our
coworkers
what
this
comment
meant
there
were
two
conflicting
interpretations
return
the
count
during
this
current
clock
minute
such
as
p
m
return
the
count
during
the
past
seconds
regardless
of
clock
minute
boundaries
the
second
interpretation
is
how
it
actually
works
so
let
s
clear
up
this
confusion
with
language
that
is
more
precise
and
detailed
return
the
accumulated
count
over
the
past
seconds
int
minutecount
similarly
we
should
improve
the
comment
for
hourcount
here
is
the
class
definition
with
all
the
changes
so
far
along
with
a
class
level
comment
track
the
cumulative
counts
over
the
past
minute
and
over
the
past
hour
useful
for
example
to
track
recent
bandwidth
usage
class
minutehourcounter
add
a
new
data
point
count
for
the
next
minute
minutecount
will
be
larger
by
count
for
the
next
hour
hourcount
will
be
larger
by
count
void
add
int
count
return
the
accumulated
count
over
the
past
seconds
int
minutecount
chapter
fifteen
return
the
accumulated
count
over
the
past
seconds
int
hourcount
for
brevity
we
ll
leave
the
comments
out
of
the
code
listings
from
now
on
getting
an
outside
perspective
you
may
have
noticed
that
there
were
already
a
couple
cases
where
we
ran
things
by
our
coworkers
asking
for
an
outside
perspective
is
a
great
way
to
test
if
your
code
is
user
friendly
try
to
be
open
to
their
first
impressions
because
other
people
may
come
to
the
same
conclusions
and
those
other
people
may
include
you
in
six
months
attempt
a
naive
solution
let
s
move
on
to
solving
the
problem
we
ll
start
with
a
straightforward
solution
just
keep
a
list
of
timestamped
events
class
minutehourcounter
struct
event
event
int
count
time
t
time
count
count
time
time
int
count
time
t
time
list
event
events
public
void
add
int
count
events
push
back
event
count
time
we
can
then
count
over
the
most
recent
events
as
needed
class
minutehourcounter
int
minutecount
int
count
const
time
t
now
secs
time
for
list
event
reverse
iterator
i
events
rbegin
i
events
rend
i
time
now
secs
i
count
i
count
return
count
designing
and
implementing
a
minute
hour
counter
int
hourcount
int
count
const
time
t
now
secs
time
for
list
event
reverse
iterator
i
events
rbegin
i
events
rend
i
time
now
secs
i
count
i
count
return
count
is
the
code
easy
to
understand
although
this
solution
is
correct
there
are
a
couple
readability
problems
the
for
loops
are
a
bit
of
a
mouthful
most
readers
slow
down
significantly
while
they
re
reading
this
part
of
the
code
at
least
they
should
if
they
re
making
sure
there
aren
t
any
bugs
minutecount
and
hourcount
are
almost
identical
it
would
make
the
code
smaller
if
they
could
share
the
duplicated
code
this
detail
is
especially
important
because
the
redundant
code
is
relatively
complex
better
to
have
all
the
difficult
code
confined
to
one
place
an
easier
to
read
version
the
code
for
minutecount
and
hourcount
differs
by
only
a
single
constant
vs
the
obvious
refactoring
is
to
introduce
a
helper
method
to
handle
both
cases
class
minutehourcounter
list
event
events
int
countsince
time
t
cutoff
int
count
for
list
event
reverse
iterator
rit
events
rbegin
rit
events
rend
rit
if
rit
time
cutoff
break
count
rit
count
return
count
public
void
add
int
count
events
push
back
event
count
time
int
minutecount
return
countsince
time
chapter
fifteen
int
hourcount
return
countsince
time
there
are
a
few
things
worth
pointing
out
about
this
new
code
first
notice
that
countsince
takes
an
absolute
cutoff
parameter
rather
than
a
relative
secs
ago
value
or
either
way
would
have
worked
but
this
way
countsince
has
a
slightly
easier
job
to
do
second
we
renamed
the
iterator
from
i
to
rit
the
name
i
is
more
commonly
used
for
integer
indexes
we
contemplated
using
the
name
it
which
is
typical
for
iterators
but
in
this
case
we
have
a
reverse
iterator
and
this
fact
is
crucial
to
the
correctness
of
the
code
by
having
a
variable
name
prefixed
with
r
it
adds
a
comforting
symmetry
to
statements
like
rit
events
rend
finally
we
extracted
the
condition
rit
time
cutoff
out
of
the
for
loop
and
made
it
a
separate
if
statement
why
because
traditional
for
loops
of
the
form
for
begin
end
advance
are
easiest
to
read
the
reader
can
immediately
understand
it
as
go
through
all
the
elements
and
doesn
t
have
to
think
about
it
further
performance
problems
although
we
ve
improved
how
the
code
looks
this
design
has
two
serious
performance
problems
it
just
keeps
growing
and
growing
the
class
holds
on
to
all
of
the
events
it
s
ever
seen
it
uses
an
unbounded
amount
of
memory
ideally
the
minutehourcounter
should
automatically
delete
events
that
are
older
than
an
hour
because
they
re
no
longer
needed
minutecount
and
hourcount
are
too
slow
the
method
countsince
takes
o
n
time
where
n
is
the
number
of
data
points
in
the
relevant
time
window
imagine
a
high
performance
server
that
called
add
hundreds
of
times
per
second
every
call
to
hourcount
would
have
to
count
through
a
million
data
points
ideally
the
minutehourcounter
should
keep
separate
minute
count
and
hour
count
variables
that
are
kept
up
date
with
each
call
to
add
attempt
conveyor
belt
design
we
need
a
design
that
solves
both
of
the
previous
problems
delete
data
we
no
longer
need
keep
precomputed
minute
count
and
hour
count
totals
up
to
date
designing
and
implementing
a
minute
hour
counter
here
s
how
we
ll
do
it
we
ll
use
our
list
like
a
conveyor
belt
when
new
data
arrives
on
one
end
we
add
to
our
total
and
when
the
data
is
too
old
it
falls
off
the
other
end
and
we
subtract
from
our
total
there
are
a
couple
ways
we
could
implement
this
conveyor
belt
design
one
way
is
to
maintain
two
independent
lists
one
for
events
in
the
past
minute
one
for
those
in
the
past
hour
when
a
new
event
comes
in
add
a
copy
to
both
lists
this
way
is
pretty
simple
but
it
s
inefficient
because
it
makes
two
copies
of
every
event
another
way
is
to
maintain
two
lists
where
events
initially
go
into
the
first
list
the
last
minute
events
and
then
this
feeds
into
the
second
list
the
last
hour
but
not
last
minute
events
this
two
stage
conveyor
belt
design
seems
more
efficient
so
let
s
implement
this
one
implementing
the
two
stage
conveyor
belt
design
let
s
begin
by
listing
the
members
of
our
class
class
minutehourcounter
list
event
minute
events
list
event
hour
events
only
contains
elements
not
in
minute
events
int
minute
count
int
hour
count
counts
all
events
over
past
hour
including
past
minute
the
crux
of
this
conveyor
belt
design
is
to
be
able
to
shift
the
events
as
time
goes
by
so
that
events
move
from
minute
events
to
hour
events
and
minute
count
and
hour
count
get
updated
chapter
fifteen
accordingly
to
do
this
we
ll
create
a
helper
method
named
shiftoldevents
once
we
have
that
method
the
rest
of
the
class
is
fairly
easy
to
implement
void
add
int
count
const
time
t
now
secs
time
shiftoldevents
now
secs
feed
into
the
minute
list
not
into
the
hour
list
that
will
happen
later
minute
events
push
back
event
count
now
secs
minute
count
count
hour
count
count
int
minutecount
shiftoldevents
time
return
minute
count
int
hourcount
shiftoldevents
time
return
hour
count
clearly
we
ve
deferred
all
the
dirty
work
to
shiftoldevents
find
and
delete
old
events
and
decrease
hour
count
and
minute
count
accordingly
void
shiftoldevents
time
t
now
secs
const
int
minute
ago
now
secs
const
int
hour
ago
now
secs
move
events
more
than
one
minute
old
from
minute
events
into
hour
events
events
older
than
one
hour
will
be
removed
in
the
second
loop
while
minute
events
empty
minute
events
front
time
minute
ago
hour
events
push
back
minute
events
front
minute
count
minute
events
front
count
minute
events
pop
front
remove
events
more
than
one
hour
old
from
hour
events
while
hour
events
empty
hour
events
front
time
hour
ago
hour
count
hour
events
front
count
hour
events
pop
front
designing
and
implementing
a
minute
hour
counter
are
we
done
we
ve
solved
the
two
performance
concerns
we
mentioned
earlier
and
our
solution
works
for
many
applications
this
solution
would
be
good
enough
but
there
are
a
number
of
deficiencies
too
first
the
design
is
very
inflexible
suppose
we
wanted
to
keep
counts
over
the
past
hours
that
would
require
making
a
lot
of
changes
to
the
code
and
as
you
probably
noticed
shiftoldevents
is
a
pretty
dense
function
with
subtle
interaction
between
the
minute
and
hour
data
second
this
class
has
a
pretty
big
memory
footprint
suppose
you
had
a
high
traffic
server
calling
add
times
per
second
because
we
hold
on
to
all
data
over
the
past
hour
this
code
would
end
up
requiring
about
mb
of
memory
in
general
the
more
frequently
add
is
called
the
more
memory
we
use
in
a
production
environment
libraries
that
use
a
large
unpredictable
amount
of
memory
aren
t
good
ideally
the
minutehourcounter
would
use
a
fixed
amount
of
memory
no
matter
how
often
add
is
called
attempt
a
time
bucketed
design
you
may
not
have
noticed
but
both
of
the
previous
implementations
had
a
small
bug
we
used
time
t
to
store
the
timestamp
which
stores
an
integral
number
of
seconds
because
of
this
rounding
minutecount
actually
returns
somewhere
between
and
seconds
worth
of
data
depending
on
when
exactly
you
call
it
for
example
if
an
event
happens
at
time
seconds
that
time
will
get
rounded
to
t
seconds
and
if
you
call
minutecount
at
time
seconds
it
will
return
the
total
for
events
where
t
so
that
first
event
will
be
missed
even
though
it
s
technically
less
than
a
minute
ago
on
average
minutecount
will
return
seconds
worth
of
data
and
hourcount
will
return
seconds
worth
of
data
a
negligible
error
we
could
fix
all
this
by
using
a
time
with
subsecond
granularity
but
interestingly
most
applications
using
a
minutehourcounter
don
t
need
that
level
of
accuracy
in
the
first
place
we
will
exploit
this
fact
to
design
a
new
minutehourcounter
that
s
much
faster
and
uses
less
space
it
s
a
trade
off
of
precision
for
performance
that
will
be
well
worth
it
the
key
idea
is
to
bucket
all
the
events
within
a
small
time
window
together
and
summarize
those
events
with
a
single
total
for
instance
the
events
over
the
past
minute
could
be
inserted
into
discrete
buckets
each
second
wide
the
events
over
the
past
hour
could
also
be
inserted
into
discrete
buckets
each
minute
wide
chapter
fifteen
using
the
buckets
as
shown
the
methods
minutecount
and
hourcount
will
be
accurate
to
part
per
which
is
reasonable
if
more
precision
is
needed
more
buckets
can
be
used
in
exchange
for
a
larger
memory
footprint
but
the
important
thing
is
that
this
design
has
a
fixed
predictable
memory
usage
implementing
the
time
bucketed
design
implementing
this
design
with
just
one
class
would
create
a
lot
of
intricate
code
that
s
hard
to
wrap
your
head
around
instead
we
re
going
to
follow
our
advice
from
chapter
one
task
at
a
time
and
create
separate
classes
to
handle
the
different
parts
of
this
problem
for
starters
let
s
create
a
separate
class
to
keep
track
of
the
counts
for
a
single
time
span
like
the
last
hour
we
ll
call
it
a
trailingbucketcounter
it
s
essentially
a
generic
version
of
minutehourcounter
that
handles
only
one
time
span
here
s
the
interface
a
class
that
keeps
counts
for
the
past
n
buckets
of
time
class
trailingbucketcounter
public
example
trailingbucketcounter
tracks
the
last
minute
buckets
of
time
trailingbucketcounter
int
num
buckets
int
secs
per
bucket
void
add
int
count
time
t
now
return
the
total
count
over
the
last
num
buckets
worth
of
time
int
trailingcount
time
t
now
you
might
wonder
why
add
and
trailingcount
require
the
current
time
time
t
now
as
an
argument
wouldn
t
it
be
easier
if
those
methods
just
computed
the
current
time
themselves
similar
to
the
previous
solutions
the
last
bucket
will
be
only
half
full
on
average
with
this
design
we
could
remedy
the
underestimate
by
keeping
buckets
instead
of
and
ignoring
the
current
inprogress
bucket
but
this
causes
the
data
to
be
partially
stale
a
better
fix
is
to
combine
the
in
progress
bucket
with
a
complementary
fraction
of
the
oldest
bucket
to
obtain
a
count
that
is
both
unbiased
and
up
to
date
this
implementation
is
left
as
an
exercise
for
the
reader
designing
and
implementing
a
minute
hour
counter
although
it
may
seem
strange
passing
in
the
current
time
has
a
couple
benefits
first
it
makes
trailingbucketcounter
a
clockless
class
which
in
general
is
easier
to
test
and
less
bug
prone
second
it
keeps
all
the
calls
to
time
inside
minutehourcounter
with
time
sensitive
systems
it
helps
if
you
can
put
all
the
calls
to
get
the
time
in
one
place
assuming
trailingbucketcounter
was
already
implemented
the
minutehourcounter
is
easy
to
implement
class
minutehourcounter
trailingbucketcounter
minute
counts
trailingbucketcounter
hour
counts
public
minutehourcounter
minute
counts
num
buckets
secs
per
bucket
hour
counts
num
buckets
secs
per
bucket
void
add
int
count
time
t
now
time
minute
counts
add
count
now
hour
counts
add
count
now
int
minutecount
time
t
now
time
return
minute
counts
trailingcount
now
int
hourcount
time
t
now
time
return
hour
counts
trailingcount
now
this
code
is
much
more
readable
and
also
more
flexible
if
we
wanted
to
increase
the
number
of
buckets
to
improve
precision
but
increase
memory
usage
that
would
be
easy
to
do
implementing
trailingbucketcounter
now
all
that
s
left
is
to
implement
the
trailingbucketcounter
class
once
again
we
re
going
to
create
a
helper
class
to
break
down
this
problem
further
we
ll
create
a
data
structure
called
conveyorqueue
whose
job
is
to
deal
with
the
underlying
counts
and
their
totals
the
trailingbucketcounter
class
can
focus
on
the
task
of
moving
the
conveyorqueue
according
to
how
much
time
has
elapsed
here
is
the
conveyorqueue
interface
a
queue
with
a
maximum
number
of
slots
where
old
data
falls
off
the
end
class
conveyorqueue
conveyorqueue
int
max
items
chapter
fifteen
increment
the
value
at
the
back
of
the
queue
void
addtoback
int
count
each
value
in
the
queue
is
shifted
forward
by
num
shifted
new
items
are
initialized
to
oldest
items
will
be
removed
so
there
are
max
items
void
shift
int
num
shifted
return
the
total
value
of
all
items
currently
in
the
queue
int
totalsum
assuming
this
class
was
implemented
look
how
easy
the
trailingbucketcounter
is
to
implement
class
trailingbucketcounter
conveyorqueue
buckets
const
int
secs
per
bucket
time
t
last
update
time
the
last
time
update
was
called
calculate
how
many
buckets
of
time
have
passed
and
shift
accordingly
void
update
time
t
now
int
current
bucket
now
secs
per
bucket
int
last
update
bucket
last
update
time
secs
per
bucket
buckets
shift
current
bucket
last
update
bucket
last
update
time
now
public
trailingbucketcounter
int
num
buckets
int
secs
per
bucket
buckets
num
buckets
secs
per
bucket
secs
per
bucket
void
add
int
count
time
t
now
update
now
buckets
addtoback
count
int
trailingcount
time
t
now
update
now
return
buckets
totalsum
this
breakdown
into
two
classes
trailingbucketcounter
and
conveyorqueue
is
another
instance
of
what
we
discussed
in
chapter
one
task
at
a
time
we
could
also
have
done
without
conveyorqueue
and
implemented
everything
directly
inside
trailingbucketcounter
but
this
way
the
code
is
easier
to
digest
designing
and
implementing
a
minute
hour
counter
implementing
conveyorqueue
now
all
that
s
left
is
to
implement
the
conveyorqueue
class
a
queue
with
a
maximum
number
of
slots
where
old
data
gets
shifted
off
the
end
class
conveyorqueue
queue
int
q
int
max
items
int
total
sum
sum
of
all
items
in
q
public
conveyorqueue
int
max
items
max
items
max
items
total
sum
int
totalsum
return
total
sum
void
shift
int
num
shifted
in
case
too
many
items
shifted
just
clear
the
queue
if
num
shifted
max
items
q
queue
int
clear
the
queue
total
sum
return
push
all
the
needed
zeros
while
num
shifted
q
push
num
shifted
let
all
the
excess
items
fall
off
while
q
size
max
items
total
sum
q
front
q
pop
void
addtoback
int
count
if
q
empty
shift
q
back
count
total
sum
count
make
sure
q
has
at
least
item
now
we
re
done
we
have
a
minutehourcounter
that
s
fast
and
memory
efficient
plus
a
more
flexible
trailingbucketcounter
that
s
easily
reusable
for
instance
it
would
be
pretty
easy
to
create
a
more
versatile
recentcounter
that
can
count
a
wide
range
of
intervals
such
as
the
last
day
or
last
ten
minutes
chapter
fifteen
comparing
the
three
solutions
let
s
compare
the
solutions
we
ve
looked
at
in
this
chapter
the
following
table
shows
the
code
size
and
performance
stats
assuming
a
high
traffic
use
case
of
add
sec
solution
lines
of
code
cost
per
hourcount
memory
use
error
in
hourcount
naive
solution
o
events
per
hour
unbounded
part
per
o
events
per
hour
part
per
million
conveyor
belt
design
o
mb
time
bucketed
design
buckets
o
o
buckets
part
per
bytes
notice
that
the
total
amount
of
code
for
our
final
three
class
solution
is
more
than
for
any
of
the
other
attempts
however
the
performance
is
far
superior
and
the
design
is
more
flexible
also
each
class
individually
is
much
easier
to
read
this
is
always
a
positive
change
having
lines
that
are
all
easy
to
read
is
better
than
lines
that
aren
t
sometimes
breaking
a
problem
into
multiple
classes
can
introduce
interclass
complexity
that
a
one
class
solution
wouldn
t
have
in
this
case
though
there
s
a
simple
linear
chain
of
use
from
one
class
to
the
next
and
only
one
of
the
classes
is
exposed
to
end
users
overall
the
benefits
of
breaking
this
problem
down
make
this
a
win
summary
let
s
review
the
steps
we
went
through
to
get
to
the
final
minutehourcounter
design
the
process
is
typical
of
how
other
pieces
of
code
evolve
first
we
started
by
coding
a
naive
solution
this
helped
us
realize
two
design
challenges
speed
and
memory
use
next
we
tried
a
conveyor
belt
design
this
design
improved
the
speed
and
memory
use
but
still
wasn
t
good
enough
for
high
performance
applications
also
this
design
was
very
inflexible
adapting
the
code
to
handle
other
time
intervals
would
be
a
lot
of
work
designing
and
implementing
a
minute
hour
counter
our
final
design
solved
the
previous
problems
by
breaking
things
down
into
subproblems
here
are
the
three
classes
we
created
in
bottom
up
order
and
the
subproblem
each
one
solved
conveyorqueue
a
maximum
length
queue
that
can
be
shifted
and
maintains
its
total
sum
trailingbucketcounter
moves
the
conveyorqueue
according
to
how
much
time
has
elapsed
and
maintains
the
count
of
a
single
latest
time
interval
with
a
given
precision
minutehourcounter
simply
contains
two
trailingbucketcounters
one
for
the
minute
count
and
one
for
the
hour
count
chapter
fifteen
appendix
further
reading
we
created
this
book
by
analyzing
hundreds
of
code
examples
from
production
code
to
figure
out
what
works
in
practice
but
we
ve
also
read
many
books
and
articles
that
helped
us
in
this
pursuit
if
you
re
interested
in
learning
more
here
are
some
resources
you
might
like
the
following
lists
are
by
no
means
complete
but
they
re
a
good
place
to
start
books
on
writing
high
quality
code
code
complete
a
practical
handbook
of
software
construction
nd
edition
by
steve
mcconnell
microsoft
press
a
rigorous
and
well
researched
tome
on
all
aspects
of
software
construction
including
code
quality
and
more
refactoring
improving
the
design
of
existing
code
by
martin
fowler
et
al
addison
wesley
professional
a
great
book
that
talks
about
the
philosophy
of
incremental
code
improvements
and
contains
a
detailed
catalog
of
many
different
refactorings
along
with
steps
to
take
to
make
these
changes
with
less
chance
of
breaking
things
the
practice
of
programming
by
brian
kernighan
and
rob
pike
addison
wesley
professional
discusses
various
aspects
of
programming
including
debugging
testing
portability
and
performance
with
various
coding
examples
the
pragmatic
programmer
from
journeyman
to
master
by
andrew
hunt
and
david
thomas
addison
wesley
professional
a
collection
of
many
good
programming
and
engineering
principles
organized
into
short
discussions
clean
code
a
handbook
of
agile
software
craftsmanship
by
robert
c
martin
prentice
hall
a
book
similar
to
ours
but
java
specific
explores
other
topics
such
as
error
handling
and
concurrency
books
on
various
programming
topics
javascript
the
good
parts
by
douglas
crockford
o
reilly
we
believe
this
book
has
a
similar
spirit
to
ours
even
though
the
book
isn
t
explicitly
about
readability
it
s
about
using
a
clean
subset
of
the
javascript
language
that
is
less
errorprone
and
easier
to
reason
about
effective
java
nd
edition
by
joshua
bloch
prentice
hall
a
phenomenal
book
about
making
your
java
programs
easier
to
read
and
more
bug
free
although
it
s
about
java
many
of
the
principles
apply
to
all
languages
highly
recommended
appendix
design
patterns
elements
of
reusable
object
oriented
software
by
erich
gamma
richard
helm
ralph
johnson
and
john
vlissides
addison
wesley
professional
the
original
book
on
a
common
language
of
patterns
for
software
engineers
to
talk
about
object
oriented
programming
as
a
catalog
of
common
useful
patterns
it
helps
programmers
avoid
the
pitfalls
that
often
happen
when
people
try
to
solve
a
tricky
problem
on
their
own
for
the
first
time
programming
pearls
nd
edition
by
jon
bentley
addison
wesley
professional
a
series
of
articles
on
real
software
problems
great
insights
on
solving
real
world
problems
in
each
chapter
high
performance
web
sites
by
steve
souders
o
reilly
although
not
a
book
about
programming
this
book
is
noteworthy
because
it
describes
a
number
of
ways
to
optimize
a
website
without
writing
much
code
in
keeping
with
chapter
writing
less
code
joel
on
software
and
on
diverse
and
by
joel
spolsky
some
of
the
best
articles
from
http
www
joelonsoftware
com
spolsky
writes
about
many
aspects
of
software
engineering
and
has
an
insightful
take
on
many
related
topics
be
sure
to
read
things
you
should
never
do
part
i
and
the
joel
test
steps
to
better
code
books
of
historical
note
writing
solid
code
by
steve
maguire
microsoft
press
this
book
has
unfortunately
become
a
bit
dated
but
it
definitely
influenced
us
with
great
advice
about
how
to
make
your
code
more
bug
free
if
you
read
it
you
ll
notice
a
lot
of
overlap
with
what
we
recommend
smalltalk
best
practice
patterns
by
kent
beck
prentice
hall
although
the
examples
are
in
smalltalk
the
book
has
many
good
programming
principles
the
elements
of
programming
style
by
brian
kernighan
and
p
j
plauger
computing
mcgrawhill
one
of
the
oldest
books
dealing
with
the
issue
of
the
clearest
way
to
write
things
most
of
the
examples
are
in
fortran
and
pl
literate
programming
by
donald
e
knuth
center
for
the
study
of
language
and
information
we
agree
wholeheartedly
with
knuth
s
statement
instead
of
imagining
that
our
main
task
is
to
instruct
a
computer
what
to
do
let
us
concentrate
rather
on
explaining
to
human
beings
what
we
want
a
computer
to
do
p
but
be
warned
the
bulk
of
the
book
is
about
knuth
s
web
programming
environment
for
documentation
web
is
effectively
a
language
for
writing
your
programs
as
works
of
literature
with
code
on
the
sidelines
further
reading
having
used
a
web
derived
system
ourselves
we
think
that
when
code
is
constantly
changing
which
is
usually
it
s
harder
to
keep
a
so
called
literate
program
fresh
than
it
is
to
keep
your
code
fresh
using
the
practices
we
recommend
appendix
index
symbols
xx
http
response
codes
xx
http
response
codes
conditional
expression
a
abbreviations
names
using
abstract
names
vs
concrete
acronyms
names
with
aesthetics
breaking
code
into
paragraphs
column
alignment
declarations
organized
into
blocks
importance
of
line
breaks
for
consistency
and
compactness
methods
to
clean
up
irregularity
order
of
code
personal
style
vs
consistency
vs
design
ajax
submitting
data
to
server
with
alert
javascript
ambiguous
names
ambiguous
pronouns
comments
with
anonymous
functions
arguments
assignment
by
name
order
in
conditionals
arrays
javascript
function
to
remove
value
from
assert
method
assertequal
method
python
assignment
inside
if
statement
attributes
encoding
in
names
authorization
of
web
page
user
php
for
b
beck
kent
smalltalk
best
practice
patterns
begin
and
end
inclusive
exclusive
ranges
using
big
picture
comments
block
scope
blocks
of
code
declarations
organized
into
booleans
names
for
rewriting
expressions
boost
c
library
bottom
up
programming
brechner
eric
bucketing
events
in
small
time
window
bugs
comments
and
off
by
one
c
c
programming
language
variable
definitions
location
c
structured
idiom
for
cleanup
code
c
block
scope
code
for
reading
file
if
statement
scope
in
inline
comment
for
named
function
parameter
macros
simplifying
expressions
standard
library
structured
idiom
for
cleanup
code
cache
adding
capitalization
names
with
cipher
class
python
class
interface
for
minute
hour
counter
class
member
variables
class
member
restricting
access
to
classes
inter
class
complexity
from
multiple
names
of
cleanup
code
structured
idiom
we
d
like
to
hear
your
suggestions
for
improving
our
indexes
send
email
to
index
oreilly
com
clever
code
confusion
from
clip
function
closure
in
javascript
code
viii
see
also
test
code
eliminating
duplicate
isolating
regions
of
less
vs
more
multiple
tasks
vs
single
qualities
of
good
redundant
removing
unused
test
friendly
development
turning
thoughts
into
understandable
writing
less
codebases
directory
for
general
purpose
code
keeping
small
column
alignment
command
line
flag
name
for
comments
ambiguous
pronouns
in
big
picture
code
flaw
descriptions
compactness
constants
explained
function
behavior
description
information
dense
words
in
input
output
examples
to
illustrate
corner
cases
insights
about
code
in
intent
statement
for
code
lining
up
minute
hour
counter
improvements
named
function
parameter
names
and
preciseness
purpose
of
reader
s
perspective
for
summary
what
why
or
how
when
not
to
use
writer
s
block
complex
idea
ability
to
explain
complexity
complicated
logic
breaking
down
concrete
names
vs
abstract
conditional
expression
conditionals
order
of
arguments
consistent
layout
line
breaks
for
personal
style
vs
constants
comments
to
explain
index
constructors
formatting
names
continue
statement
control
flow
conditional
expression
early
return
from
function
eliminating
variables
following
flow
of
execution
goto
statement
nesting
conveyorqueue
interface
implementing
cookies
in
javascript
copy
constructor
default
corner
cases
input
output
comment
examples
to
illustrate
crutch
comments
d
dashes
names
with
database
tables
program
to
join
de
morgan
s
laws
declarations
organized
into
blocks
defragmenting
code
deleting
unused
code
design
vs
aesthetics
development
time
sweet
spot
for
dictionary
in
python
sensitive
information
in
disallow
copy
and
assign
macro
disallow
evil
constructor
macro
do
while
loops
avoiding
dry
don
t
repeat
yourself
principle
duplicated
code
eliminating
e
eclipse
word
completion
command
emacs
word
completion
command
end
inclusive
exclusive
ranges
using
error
messages
hand
crafted
readability
exceptions
execution
flow
following
expectations
of
users
matching
explaining
variables
expressions
breaking
down
complicated
logic
in
one
line
vs
multiple
lines
short
circuit
logic
abuse
simplifying
external
components
testing
issues
extracting
see
also
subproblems
code
extraction
values
from
object
f
false
features
decision
not
to
implement
file
contents
reading
filter
function
findclosestlocation
example
first
and
last
inclusive
ranges
using
fixme
marker
flow
of
execution
following
for
loops
removing
nesting
inside
formatting
names
meaning
from
format
pretty
function
fowler
martin
refactoring
improving
the
design
of
existing
code
function
pointers
functionality
project
specific
functions
anonymous
comments
for
behavior
description
early
return
from
extracting
code
into
separate
names
of
wrapper
fundamental
theory
of
readability
g
general
purpose
code
creating
generic
names
get
methods
user
expectations
for
global
scope
javascript
global
variables
avoiding
testability
google
disallow
evil
constructor
macro
formatting
conventions
for
open
source
projects
gosling
james
goto
statement
h
hack
marker
helper
methods
names
in
test
code
shiftoldevents
in
minute
hour
counter
test
code
clean
up
with
high
level
comments
html
tags
id
or
class
attribute
names
httpdownload
object
hungarian
notation
i
if
statement
assignment
inside
handling
separate
name
of
index
for
order
of
arguments
scope
in
c
if
else
blocks
order
of
immutable
data
types
implementing
features
decision
not
to
inclusive
ranges
first
and
last
for
inclusive
exclusive
ranges
begin
and
end
for
indices
names
for
information
dense
words
comments
with
inline
comments
named
function
parameters
in
input
values
choosing
good
for
test
input
output
comment
examples
to
illustrate
corner
cases
intellij
idea
word
completion
command
interface
reshaping
simplifying
existing
intermediate
result
variable
eliminating
isolating
regions
of
code
j
java
block
scope
inline
comment
for
named
function
parameter
structured
idiom
for
cleanup
code
javascript
alert
cookies
findclosestlocation
example
formatting
names
function
to
remove
value
from
array
global
scope
no
nested
scope
or
operator
private
variables
in
jquery
javascript
library
jquery
library
function
formatting
names
l
last
inclusive
ranges
using
libraries
knowledge
of
regular
expressions
index
limits
names
for
line
breaks
in
code
lines
of
code
minimizing
vs
time
requirements
list
size
method
user
expectations
for
lists
in
python
logic
breaking
down
complicated
clear
description
loop
iterators
loops
removing
nesting
inside
m
macros
c
matching
database
rows
python
code
to
find
max
for
inclusive
limits
memory
leaks
memory
requirements
mental
baggage
messy
code
comment
for
min
for
inclusive
limits
minilanguages
implementing
custom
minute
hour
counter
class
interface
comments
comparing
solutions
conveyor
belt
design
naive
solution
performance
problems
time
bucketed
design
trailingbucketcounter
implementation
n
named
function
parameter
comments
names
acronyms
or
abbreviations
in
avoiding
misunderstanding
booleans
comments
and
concrete
vs
abstract
encoding
attributes
evaluating
multiple
candidates
formatting
for
meaning
generic
information
in
length
of
limits
loop
iterator
options
measurement
units
in
minutehourcounter
class
improvements
python
argument
assignment
by
specificity
of
words
and
index
for
test
functions
negative
case
in
if
else
vs
positive
nesting
accumulating
removing
by
early
return
removing
inside
loops
nondeterministic
behavior
o
off
by
one
bug
openbsd
operating
system
wizard
mode
or
operator
order
of
code
p
paragraphs
breaking
code
into
performance
vs
precision
personal
style
vs
consistency
perspective
of
others
php
reading
file
contents
user
authorization
for
web
page
pitfalls
anticipating
with
comments
plain
english
code
explanation
in
test
description
in
plaintext
indicator
in
names
positive
case
in
if
else
vs
negative
precision
vs
performance
printf
private
variables
in
javascript
problems
anticipating
with
comments
in
test
code
product
development
testing
as
limitation
project
specific
functionality
prototype
inheritance
pattern
evaluating
names
for
purpose
of
entity
name
choices
and
python
argument
assignment
by
name
assert
statement
code
to
find
matching
database
rows
dictionary
with
sensitive
user
information
lists
and
sets
no
nested
scope
or
operator
reading
file
contents
structured
idiom
for
cleanup
code
unittest
module
and
test
method
names
q
questions
anticipating
with
comments
r
ranges
inclusive
first
and
last
for
inclusive
exclusive
begin
and
end
for
readability
error
messages
and
fundamental
theory
of
test
code
and
variables
and
reading
file
contents
redundancy
check
comment
as
redundant
code
refactoring
improving
the
design
of
existing
code
fowler
regular
expressions
libraries
precompiling
removing
unused
code
requirements
questions
and
breakdown
return
value
name
for
returning
early
from
function
removing
nesting
by
reverse
iterator
ruby
or
operator
run
locally
command
line
flag
s
scope
global
in
javascript
if
statement
in
c
name
length
and
of
variables
shrinking
security
bug
names
and
sets
in
python
shiftoldevents
method
short
circuit
logic
abuse
signal
interrupt
handlers
silhouette
of
code
smalltalk
best
practice
patterns
beck
specificity
of
words
name
selection
and
statements
breaking
down
static
methods
statistics
incrementing
stock
purchases
recording
store
locator
for
business
stroustrup
bjarne
subproblems
code
extraction
findclosestlocation
example
general
purpose
code
project
specific
functionality
simplifying
existing
interface
taking
things
too
far
utility
code
summary
comments
summary
variables
surface
level
improvements
t
tasks
extracting
values
from
object
multiple
vs
single
size
of
updatecounts
function
example
temporary
variables
ternary
operator
test
code
creating
minimal
statement
helper
method
names
in
locating
problems
in
readability
test
driven
development
tdd
testing
checkscoresbeforeafter
function
for
choosing
good
input
values
code
development
and
going
too
far
and
good
design
identifying
problems
in
large
inputs
for
multiple
tests
of
functionality
names
for
test
functions
website
changes
text
editors
word
completion
command
textmate
word
completion
command
threading
time
requirement
for
understanding
code
time
sensitive
systems
tmp
variable
alternative
todo
marker
top
down
programming
trailingbucketcounter
class
true
typo
column
alignment
to
find
u
underscores
names
with
unix
tools
updatecounts
function
user
authorization
for
web
page
php
for
user
information
python
dictionary
with
sensitive
users
matching
expectations
utility
code
extracting
v
values
extracting
from
object
var
keyword
javascript
variables
index
class
member
eliminating
eliminating
intermediate
results
explaining
global
testability
impact
on
readability
measurement
units
in
name
moving
definitions
down
names
of
order
of
definitions
private
in
javascript
shrinking
scope
summary
swapping
name
choices
when
temporary
write
once
vi
word
completion
command
virtual
methods
w
web
pages
php
for
user
authorization
web
server
tracking
bytes
transferred
see
minute
hour
counter
websites
experiments
to
test
change
while
loops
order
of
arguments
vs
do
while
loops
word
completion
command
long
names
and
wrapper
functions
write
once
variables
writer
s
block
comments
and
x
xxx
marker
index
about
the
authors
although
raised
in
the
circus
dustin
boswell
realized
early
on
that
he
was
better
at
computers
than
at
acrobatics
dustin
received
his
b
s
from
caltech
where
he
got
hooked
on
computer
science
and
then
went
to
uc
san
diego
for
his
master
s
degree
he
worked
at
google
for
five
years
on
a
variety
of
projects
including
web
crawling
infrastructure
he
s
built
numerous
websites
and
enjoys
working
on
big
data
and
machine
learning
dustin
is
now
an
internet
startup
junkie
who
spends
his
free
time
hiking
the
santa
monica
mountains
and
being
a
new
dad
trevor
foucher
has
worked
on
large
scale
software
development
at
microsoft
and
google
for
over
years
he
is
currently
an
engineer
on
search
infrastructure
at
google
in
his
spare
time
he
attends
gaming
conventions
reads
science
fiction
and
serves
as
coo
of
his
wife
s
fashion
start
up
company
trevor
graduated
with
a
bs
degree
in
electrical
engineering
and
computer
science
from
uc
berkeley
colophon
the
cover
image
is
from
getty
images
the
cover
fonts
are
akzidenz
grotesk
and
orator
the
text
font
is
adobe
s
meridien
the
heading
font
is
itc
bailey
